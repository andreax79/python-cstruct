{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python-CStruct C-style structs for Python Convert C struct/union definitions into Python classes with methods for serializing/deserializing. The usage is very simple: create a class subclassing cstruct.MemCStruct and add a C struct/union definition as a string in the __def__ field. The C struct/union definition is parsed at runtime and the struct format string is generated. The class offers the method unpack for deserializing an array of bytes into a Python object and the method pack for serializing the values into an array of bytes. Install pip install cstruct Examples Read the DOS-type (MBR) partition table Print information about logged uses Flexible Array Member (FAM) libc integration (using ctypes) Features Structs Struct definition subclassing cstruct.MemCStruct . Methods can access stuct values as instance variables. class Position(cstruct.MemCStruct): __def__ = \"\"\" struct { unsigned char head; unsigned char sector; unsigned char cyl; } \"\"\" @property def lba(self): return (self.cyl * 16 + self.head) * 63 + (self.sector - 1) pos = Position(cyl=15, head=15, sector=63) print(f\"head: {pos.head} sector: {pos.sector} cyl: {pos.cyl} lba: {pos.lba}\") Struct definition using cstruct.parse . Partition = cstruct.parse(\"\"\" #define ACTIVE_FLAG 0x80 struct Partition { unsigned char status; /* 0x80 - active */ struct Position start; unsigned char partition_type; struct Position end; unsigned int start_sect; /* starting sector counting from 0 */ unsigned int sectors; /* nr of sectors in partition */ } \"\"\") part = Partition() part.status = cstruct.getdef('ACTIVE_FLAG') Unions Union definition subclassing cstruct.MemCStruct . class Data(cstruct.MemCStruct): __def__ = \"\"\" union { int integer; float real; } \"\"\" data = Data() data.integer = 2 data.real = 3 assert data.integer != 2 Enums Enum definition subclassing cstruct.CEnum . class HtmlFont(cstruct.CEnum): __size__ = 2 __def__ = \"\"\" #define NONE 0 enum htmlfont { HTMLFONT_NONE = NONE, HTMLFONT_BOLD, HTMLFONT_ITALIC } \"\"\" assert HtmlFont.HTMLFONT_NONE == 0 assert HtmlFont.HTMLFONT_BOLD == 1 assert HtmlFont.HTMLFONT_ITALIC == 2 Different enum styles are supported in struct/union definitions. enum Type_A a; // externally defined using CEnum enum Type_B {A, B, C} b; enum {A, B, C} c; enum Type_D : short {A, B, C} d; // specify the underlying type enum Direction { left = 'l', right = 'r' }; Nested structs/unions Nested stucts and unions are supported, both named and anonymous. class Packet(cstruct.MemCStruct): __def__ = \"\"\" struct Packet { uint8_t packetLength; union { struct { uint16_t field1; uint16_t field2; uint16_t field3; } format1; struct { double value1; double value2; } format2; }; }; \"\"\" Byte Order, Size, and Padding Suported byte orders: cstruct.LITTLE_ENDIAN - Little endian byte order, standard size, no padding cstruct.BIG_ENDIAN - Big endian byte order, standard size, no padding cstruct.NATIVE_ORDER - Native byte order, native size, padding class Native(cstruct.MemCStruct): __byte_order__ = cstruct.NATIVE_ORDER __def__ = \"\"\" struct { long p; char c; long x; } \"\"\" Flexible Array Member class Pkg(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct { uint16_t cmd; uint16_t length; uint8_t data[]; } \"\"\" pkg = Pkg() pkg.length = 4 pkg.data = [10, 20, 30, 40] Python object attributes In struct definition, you can access Python object attributes using self . The value of expression accessing class attributes is evaluated at runtime. class RT11DirectoryEntry(cstruct.CStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct RT11DirectoryEntry { uint8_t type; uint8_t clazz; uint16_t raw_filename1; uint16_t raw_filename2; uint16_t raw_extension; uint16_t length; uint8_t job; uint8_t channel; uint16_t raw_creation_date; uint16_t extra_bytes[self.extra_bytes_len]; /* The size of the array is determined at runtime */ }; \"\"\" extra_bytes_len: int = 0 Pack and Unpack A code example illustrating how to use pack to pack a structure into binary form. class Position(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct { unsigned char head; unsigned char sector; unsigned char cyl; } \"\"\" pos = Position(head=10, sector=20, cyl=3) packed = pos.pack() Binary representation can be converted into structure using unpack . pos1 = Position() pos1.unpack(packed) assert pos1.head == 10 assert pos1.sector == 20 assert pos1.cyl == 3 Define, Sizeof, and Eval Definitions in Struct declaration: class Packet(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" #define MaxPacket 20 struct Packet { uint8_t bytes[MaxPacket]; } \"\"\" Parse C definitions: cstruct.parse(\"\"\" #define A1 10 #define A2 10 + A1 #define A3 30 \"\"\") assert cstruct.getdef(\"A1\") == 10 assert cstruct.getdef('A2') == 20 Get structure size: cstruct.sizeof(Partition) Evaluate C expression using c_eval : cstruct.c_eval(\"A1 / 10\") cstruct.c_eval(\"((A10 < 6) || (A10>10))\") C expressions are automatically evaluated during structure definitions: class MBR(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" #define MBR_SIZE 512 #define MBR_DISK_SIGNATURE_SIZE 4 #define MBR_USUALY_NULLS_SIZE 2 #define MBR_SIGNATURE_SIZE 2 #define MBR_BOOT_SIGNATURE 0xaa55 #define MBR_PARTITIONS_NUM 4 #define MBR_PARTITIONS_SIZE (sizeof(Partition) * MBR_PARTITIONS_NUM) #define MBR_UNUSED_SIZE (MBR_SIZE - MBR_DISK_SIGNATURE_SIZE - MBR_USUALY_NULLS_SIZE - MBR_PARTITIONS_SIZE - MBR_SIGNATURE_SIZE) struct { char unused[MBR_UNUSED_SIZE]; unsigned char disk_signature[MBR_DISK_SIGNATURE_SIZE]; unsigned char usualy_nulls[MBR_USUALY_NULLS_SIZE]; struct Partition partitions[MBR_PARTITIONS_NUM]; uint16 signature; } \"\"\" Ispect memory The inspect methods displays memory contents in hexadecimal. print(mbr.inspect()) Output example: 00000000 eb 48 90 00 00 00 00 00 00 00 00 00 00 00 00 00 |.H..............| 00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 02 |................| 00000040 ff 00 00 80 61 cb 04 00 00 08 fa 80 ca 80 ea 53 |....a..........S| 00000050 7c 00 00 31 c0 8e d8 8e d0 bc 00 20 fb a0 40 7c ||..1....... ..@|| 00000060 3c ff 74 02 88 c2 52 be 79 7d e8 34 01 f6 c2 80 |<.t...R.y}.4....| 00000070 74 54 b4 41 bb aa 55 cd 13 5a 52 72 49 81 fb 55 |tT.A..U..ZRrI..U| 00000080 aa 75 43 a0 41 7c 84 c0 75 05 83 e1 01 74 37 66 |.uC.A|..u....t7f| 00000090 8b 4c 10 be 05 7c c6 44 ff 01 66 8b 1e 44 7c c7 |.L...|.D..f..D|.| 000000a0 04 10 00 c7 44 02 01 00 66 89 5c 08 c7 44 06 00 |....D...f.\\..D..| 000000b0 70 66 31 c0 89 44 04 66 89 44 0c b4 42 cd 13 72 |pf1..D.f.D..B..r| 000000c0 05 bb 00 70 eb 7d b4 08 cd 13 73 0a f6 c2 80 0f |...p.}....s.....| 000000d0 84 f0 00 e9 8d 00 be 05 7c c6 44 ff 00 66 31 c0 |........|.D..f1.| 000000e0 88 f0 40 66 89 44 04 31 d2 88 ca c1 e2 02 88 e8 |..@f.D.1........| 000000f0 88 f4 40 89 44 08 31 c0 88 d0 c0 e8 02 66 89 04 |..@.D.1......f..| 00000100 66 a1 44 7c 66 31 d2 66 f7 34 88 54 0a 66 31 d2 |f.D|f1.f.4.T.f1.| 00000110 66 f7 74 04 88 54 0b 89 44 0c 3b 44 08 7d 3c 8a |f.t..T..D.;D.}<.| 00000120 54 0d c0 e2 06 8a 4c 0a fe c1 08 d1 8a 6c 0c 5a |T.....L......l.Z| 00000130 8a 74 0b bb 00 70 8e c3 31 db b8 01 02 cd 13 72 |.t...p..1......r| 00000140 2a 8c c3 8e 06 48 7c 60 1e b9 00 01 8e db 31 f6 |*....H|`......1.| 00000150 31 ff fc f3 a5 1f 61 ff 26 42 7c be 7f 7d e8 40 |1.....a.&B|..}.@| 00000160 00 eb 0e be 84 7d e8 38 00 eb 06 be 8e 7d e8 30 |.....}.8.....}.0| 00000170 00 be 93 7d e8 2a 00 eb fe 47 52 55 42 20 00 47 |...}.*...GRUB .G| 00000180 65 6f 6d 00 48 61 72 64 20 44 69 73 6b 00 52 65 |eom.Hard Disk.Re| 00000190 61 64 00 20 45 72 72 6f 72 00 bb 01 00 b4 0e cd |ad. Error.......| 000001a0 10 ac 3c 00 75 f4 c3 00 00 00 00 00 00 00 00 00 |..<.u...........| 000001b0 00 00 00 00 00 00 00 00 40 e2 01 00 00 00 80 00 |........@.......| 000001c0 02 00 83 fe 3f 86 01 00 00 00 c6 17 21 00 00 00 |....?.......!...| 000001d0 01 87 8e fe ff ff c7 17 21 00 4d d3 de 00 00 00 |........!.M.....| 000001e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.| Links C/C++ reference","title":"Introduction"},{"location":"#python-cstruct","text":"C-style structs for Python Convert C struct/union definitions into Python classes with methods for serializing/deserializing. The usage is very simple: create a class subclassing cstruct.MemCStruct and add a C struct/union definition as a string in the __def__ field. The C struct/union definition is parsed at runtime and the struct format string is generated. The class offers the method unpack for deserializing an array of bytes into a Python object and the method pack for serializing the values into an array of bytes.","title":"Python-CStruct"},{"location":"#install","text":"pip install cstruct","title":"Install"},{"location":"#examples","text":"Read the DOS-type (MBR) partition table Print information about logged uses Flexible Array Member (FAM) libc integration (using ctypes)","title":"Examples"},{"location":"#features","text":"","title":"Features"},{"location":"#structs","text":"Struct definition subclassing cstruct.MemCStruct . Methods can access stuct values as instance variables. class Position(cstruct.MemCStruct): __def__ = \"\"\" struct { unsigned char head; unsigned char sector; unsigned char cyl; } \"\"\" @property def lba(self): return (self.cyl * 16 + self.head) * 63 + (self.sector - 1) pos = Position(cyl=15, head=15, sector=63) print(f\"head: {pos.head} sector: {pos.sector} cyl: {pos.cyl} lba: {pos.lba}\") Struct definition using cstruct.parse . Partition = cstruct.parse(\"\"\" #define ACTIVE_FLAG 0x80 struct Partition { unsigned char status; /* 0x80 - active */ struct Position start; unsigned char partition_type; struct Position end; unsigned int start_sect; /* starting sector counting from 0 */ unsigned int sectors; /* nr of sectors in partition */ } \"\"\") part = Partition() part.status = cstruct.getdef('ACTIVE_FLAG')","title":"Structs"},{"location":"#unions","text":"Union definition subclassing cstruct.MemCStruct . class Data(cstruct.MemCStruct): __def__ = \"\"\" union { int integer; float real; } \"\"\" data = Data() data.integer = 2 data.real = 3 assert data.integer != 2","title":"Unions"},{"location":"#enums","text":"Enum definition subclassing cstruct.CEnum . class HtmlFont(cstruct.CEnum): __size__ = 2 __def__ = \"\"\" #define NONE 0 enum htmlfont { HTMLFONT_NONE = NONE, HTMLFONT_BOLD, HTMLFONT_ITALIC } \"\"\" assert HtmlFont.HTMLFONT_NONE == 0 assert HtmlFont.HTMLFONT_BOLD == 1 assert HtmlFont.HTMLFONT_ITALIC == 2 Different enum styles are supported in struct/union definitions. enum Type_A a; // externally defined using CEnum enum Type_B {A, B, C} b; enum {A, B, C} c; enum Type_D : short {A, B, C} d; // specify the underlying type enum Direction { left = 'l', right = 'r' };","title":"Enums"},{"location":"#nested-structsunions","text":"Nested stucts and unions are supported, both named and anonymous. class Packet(cstruct.MemCStruct): __def__ = \"\"\" struct Packet { uint8_t packetLength; union { struct { uint16_t field1; uint16_t field2; uint16_t field3; } format1; struct { double value1; double value2; } format2; }; }; \"\"\"","title":"Nested structs/unions"},{"location":"#byte-order-size-and-padding","text":"Suported byte orders: cstruct.LITTLE_ENDIAN - Little endian byte order, standard size, no padding cstruct.BIG_ENDIAN - Big endian byte order, standard size, no padding cstruct.NATIVE_ORDER - Native byte order, native size, padding class Native(cstruct.MemCStruct): __byte_order__ = cstruct.NATIVE_ORDER __def__ = \"\"\" struct { long p; char c; long x; } \"\"\"","title":"Byte Order, Size, and Padding"},{"location":"#flexible-array-member","text":"class Pkg(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct { uint16_t cmd; uint16_t length; uint8_t data[]; } \"\"\" pkg = Pkg() pkg.length = 4 pkg.data = [10, 20, 30, 40]","title":"Flexible Array Member"},{"location":"#python-object-attributes","text":"In struct definition, you can access Python object attributes using self . The value of expression accessing class attributes is evaluated at runtime. class RT11DirectoryEntry(cstruct.CStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct RT11DirectoryEntry { uint8_t type; uint8_t clazz; uint16_t raw_filename1; uint16_t raw_filename2; uint16_t raw_extension; uint16_t length; uint8_t job; uint8_t channel; uint16_t raw_creation_date; uint16_t extra_bytes[self.extra_bytes_len]; /* The size of the array is determined at runtime */ }; \"\"\" extra_bytes_len: int = 0","title":"Python object attributes"},{"location":"#pack-and-unpack","text":"A code example illustrating how to use pack to pack a structure into binary form. class Position(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct { unsigned char head; unsigned char sector; unsigned char cyl; } \"\"\" pos = Position(head=10, sector=20, cyl=3) packed = pos.pack() Binary representation can be converted into structure using unpack . pos1 = Position() pos1.unpack(packed) assert pos1.head == 10 assert pos1.sector == 20 assert pos1.cyl == 3","title":"Pack and Unpack"},{"location":"#define-sizeof-and-eval","text":"Definitions in Struct declaration: class Packet(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" #define MaxPacket 20 struct Packet { uint8_t bytes[MaxPacket]; } \"\"\" Parse C definitions: cstruct.parse(\"\"\" #define A1 10 #define A2 10 + A1 #define A3 30 \"\"\") assert cstruct.getdef(\"A1\") == 10 assert cstruct.getdef('A2') == 20 Get structure size: cstruct.sizeof(Partition) Evaluate C expression using c_eval : cstruct.c_eval(\"A1 / 10\") cstruct.c_eval(\"((A10 < 6) || (A10>10))\") C expressions are automatically evaluated during structure definitions: class MBR(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" #define MBR_SIZE 512 #define MBR_DISK_SIGNATURE_SIZE 4 #define MBR_USUALY_NULLS_SIZE 2 #define MBR_SIGNATURE_SIZE 2 #define MBR_BOOT_SIGNATURE 0xaa55 #define MBR_PARTITIONS_NUM 4 #define MBR_PARTITIONS_SIZE (sizeof(Partition) * MBR_PARTITIONS_NUM) #define MBR_UNUSED_SIZE (MBR_SIZE - MBR_DISK_SIGNATURE_SIZE - MBR_USUALY_NULLS_SIZE - MBR_PARTITIONS_SIZE - MBR_SIGNATURE_SIZE) struct { char unused[MBR_UNUSED_SIZE]; unsigned char disk_signature[MBR_DISK_SIGNATURE_SIZE]; unsigned char usualy_nulls[MBR_USUALY_NULLS_SIZE]; struct Partition partitions[MBR_PARTITIONS_NUM]; uint16 signature; } \"\"\"","title":"Define, Sizeof, and Eval"},{"location":"#ispect-memory","text":"The inspect methods displays memory contents in hexadecimal. print(mbr.inspect()) Output example: 00000000 eb 48 90 00 00 00 00 00 00 00 00 00 00 00 00 00 |.H..............| 00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 00000030 00 00 00 00 00 00 00 00 00 00 00 00 00 00 03 02 |................| 00000040 ff 00 00 80 61 cb 04 00 00 08 fa 80 ca 80 ea 53 |....a..........S| 00000050 7c 00 00 31 c0 8e d8 8e d0 bc 00 20 fb a0 40 7c ||..1....... ..@|| 00000060 3c ff 74 02 88 c2 52 be 79 7d e8 34 01 f6 c2 80 |<.t...R.y}.4....| 00000070 74 54 b4 41 bb aa 55 cd 13 5a 52 72 49 81 fb 55 |tT.A..U..ZRrI..U| 00000080 aa 75 43 a0 41 7c 84 c0 75 05 83 e1 01 74 37 66 |.uC.A|..u....t7f| 00000090 8b 4c 10 be 05 7c c6 44 ff 01 66 8b 1e 44 7c c7 |.L...|.D..f..D|.| 000000a0 04 10 00 c7 44 02 01 00 66 89 5c 08 c7 44 06 00 |....D...f.\\..D..| 000000b0 70 66 31 c0 89 44 04 66 89 44 0c b4 42 cd 13 72 |pf1..D.f.D..B..r| 000000c0 05 bb 00 70 eb 7d b4 08 cd 13 73 0a f6 c2 80 0f |...p.}....s.....| 000000d0 84 f0 00 e9 8d 00 be 05 7c c6 44 ff 00 66 31 c0 |........|.D..f1.| 000000e0 88 f0 40 66 89 44 04 31 d2 88 ca c1 e2 02 88 e8 |..@f.D.1........| 000000f0 88 f4 40 89 44 08 31 c0 88 d0 c0 e8 02 66 89 04 |..@.D.1......f..| 00000100 66 a1 44 7c 66 31 d2 66 f7 34 88 54 0a 66 31 d2 |f.D|f1.f.4.T.f1.| 00000110 66 f7 74 04 88 54 0b 89 44 0c 3b 44 08 7d 3c 8a |f.t..T..D.;D.}<.| 00000120 54 0d c0 e2 06 8a 4c 0a fe c1 08 d1 8a 6c 0c 5a |T.....L......l.Z| 00000130 8a 74 0b bb 00 70 8e c3 31 db b8 01 02 cd 13 72 |.t...p..1......r| 00000140 2a 8c c3 8e 06 48 7c 60 1e b9 00 01 8e db 31 f6 |*....H|`......1.| 00000150 31 ff fc f3 a5 1f 61 ff 26 42 7c be 7f 7d e8 40 |1.....a.&B|..}.@| 00000160 00 eb 0e be 84 7d e8 38 00 eb 06 be 8e 7d e8 30 |.....}.8.....}.0| 00000170 00 be 93 7d e8 2a 00 eb fe 47 52 55 42 20 00 47 |...}.*...GRUB .G| 00000180 65 6f 6d 00 48 61 72 64 20 44 69 73 6b 00 52 65 |eom.Hard Disk.Re| 00000190 61 64 00 20 45 72 72 6f 72 00 bb 01 00 b4 0e cd |ad. Error.......| 000001a0 10 ac 3c 00 75 f4 c3 00 00 00 00 00 00 00 00 00 |..<.u...........| 000001b0 00 00 00 00 00 00 00 00 40 e2 01 00 00 00 80 00 |........@.......| 000001c0 02 00 83 fe 3f 86 01 00 00 00 c6 17 21 00 00 00 |....?.......!...| 000001d0 01 87 8e fe ff ff c7 17 21 00 4d d3 de 00 00 00 |........!.M.....| 000001e0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| 000001f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa |..............U.|","title":"Ispect memory"},{"location":"#links","text":"C/C++ reference","title":"Links"},{"location":"CODE_OF_CONDUCT/","text":"Contributor Covenant Code of Conduct Our Pledge We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community. Our Standards Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Enforcement Responsibilities Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate. Scope This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at andrea.bonomi@gmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident. Enforcement Guidelines Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct: 1. Correction Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested. 2. Warning Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban. 3. Temporary Ban Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban. 4. Permanent Ban Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Code of Conduct"},{"location":"CODE_OF_CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE_OF_CONDUCT/#our-pledge","text":"We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.","title":"Our Pledge"},{"location":"CODE_OF_CONDUCT/#our-standards","text":"Examples of behavior that contributes to a positive environment for our community include: Demonstrating empathy and kindness toward other people Being respectful of differing opinions, viewpoints, and experiences Giving and gracefully accepting constructive feedback Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience Focusing on what is best not just for us as individuals, but for the overall community Examples of unacceptable behavior include: The use of sexualized language or imagery, and sexual attention or advances of any kind Trolling, insulting or derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or email address, without their explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","text":"Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful. Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.","title":"Enforcement Responsibilities"},{"location":"CODE_OF_CONDUCT/#scope","text":"This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.","title":"Scope"},{"location":"CODE_OF_CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at andrea.bonomi@gmail.com. All complaints will be reviewed and investigated promptly and fairly. All community leaders are obligated to respect the privacy and security of the reporter of any incident.","title":"Enforcement"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","text":"Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:","title":"Enforcement Guidelines"},{"location":"CODE_OF_CONDUCT/#1-correction","text":"Community Impact : Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. Consequence : A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.","title":"1. Correction"},{"location":"CODE_OF_CONDUCT/#2-warning","text":"Community Impact : A violation through a single incident or series of actions. Consequence : A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.","title":"2. Warning"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","text":"Community Impact : A serious violation of community standards, including sustained inappropriate behavior. Consequence : A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.","title":"3. Temporary Ban"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","text":"Community Impact : Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals. Consequence : A permanent ban from any sort of public interaction within the community.","title":"4. Permanent Ban"},{"location":"CODE_OF_CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder . For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.","title":"Attribution"},{"location":"changelog/","text":"Changelog [1.0] - 2013-08-19 Added initial version [1.2] - 2017-05-18 Improved initialize all values to 0 by default new data types Added who.py example a changelog :) [1.3] - 2017-05-21 Fix default value fix [1.4] - 2017-06-02 Fix default value fix [1.5] - 2017-07-22 Fix compatibiliy fix [1.6] - 2017-12-12 Fix fixed size of 64-bit integers, they now have 64 bits, not 32 [1.7] - 2018-03-14 Improved add support for // comments [1.8] - 2018-10-30 Improved add *_t types Fix fix Python 2.5 support in main module examples fix [1.9] - 2019-07-09 Improved drop Python < 2.6 support Added flexible array parsing union initial support [2.0] - 2020-04-11 Improved drop Python 2 support [2.1] - 2020-10-09 Improved refactoring Python 3.9 support Github workfows [2.2] - 2022-08-23 Fix Fix empty MemCStruct size Improved Python 3.10 support pytest black code style [2.3] - 2022-09-01 Fix Fix compare with None [3.0] - 2022-09-05 Added Flexible array support [3.1] - 2022-09-13 Added Make CStruct/MemCStruct Pickle Friendly [3.2] - 2022-10-23 Fix Fix padding tests on 32bit architectures [3.3] - 2022-10-24 Added Add 32bit test environment Fix Fix padding tests on 32bit architectures [4.0] - 2022-11-01 Added Add support for nameless inline struct Improved Python 3.11 support [5.0] - 2022-11-12 Added Add support for enums Add support for multiple definition to cstruct.parse Add inspect method Improved Documentation and examples Restructure setup [5.1] - 2022-11-20 Improved Support unpack from ctype pointers Added Add support for char constants Add native type test dir.py example [5.2] - 2022-11-23 Fix nested struct unpack fix nested anonymous union offset fix inspect offset for nested struct/union fix [5.3] - 2024-01-08 Fix fix struct in struct array parsing Improved Python 3.12 support [6.0] - 2025-01-16 Added access to Python class attributes in struct definition Improved Python 3.13 support","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#10-2013-08-19","text":"","title":"[1.0] - 2013-08-19"},{"location":"changelog/#added","text":"initial version","title":"Added"},{"location":"changelog/#12-2017-05-18","text":"","title":"[1.2] - 2017-05-18"},{"location":"changelog/#improved","text":"initialize all values to 0 by default new data types","title":"Improved"},{"location":"changelog/#added_1","text":"who.py example a changelog :)","title":"Added"},{"location":"changelog/#13-2017-05-21","text":"","title":"[1.3] - 2017-05-21"},{"location":"changelog/#fix","text":"default value fix","title":"Fix"},{"location":"changelog/#14-2017-06-02","text":"","title":"[1.4] - 2017-06-02"},{"location":"changelog/#fix_1","text":"default value fix","title":"Fix"},{"location":"changelog/#15-2017-07-22","text":"","title":"[1.5] - 2017-07-22"},{"location":"changelog/#fix_2","text":"compatibiliy fix","title":"Fix"},{"location":"changelog/#16-2017-12-12","text":"","title":"[1.6] - 2017-12-12"},{"location":"changelog/#fix_3","text":"fixed size of 64-bit integers, they now have 64 bits, not 32","title":"Fix"},{"location":"changelog/#17-2018-03-14","text":"","title":"[1.7] - 2018-03-14"},{"location":"changelog/#improved_1","text":"add support for // comments","title":"Improved"},{"location":"changelog/#18-2018-10-30","text":"","title":"[1.8] - 2018-10-30"},{"location":"changelog/#improved_2","text":"add *_t types","title":"Improved"},{"location":"changelog/#fix_4","text":"fix Python 2.5 support in main module examples fix","title":"Fix"},{"location":"changelog/#19-2019-07-09","text":"","title":"[1.9] - 2019-07-09"},{"location":"changelog/#improved_3","text":"drop Python < 2.6 support","title":"Improved"},{"location":"changelog/#added_2","text":"flexible array parsing union initial support","title":"Added"},{"location":"changelog/#20-2020-04-11","text":"","title":"[2.0] - 2020-04-11"},{"location":"changelog/#improved_4","text":"drop Python 2 support","title":"Improved"},{"location":"changelog/#21-2020-10-09","text":"","title":"[2.1] - 2020-10-09"},{"location":"changelog/#improved_5","text":"refactoring Python 3.9 support Github workfows","title":"Improved"},{"location":"changelog/#22-2022-08-23","text":"","title":"[2.2] - 2022-08-23"},{"location":"changelog/#fix_5","text":"Fix empty MemCStruct size","title":"Fix"},{"location":"changelog/#improved_6","text":"Python 3.10 support pytest black code style","title":"Improved"},{"location":"changelog/#23-2022-09-01","text":"","title":"[2.3] - 2022-09-01"},{"location":"changelog/#fix_6","text":"Fix compare with None","title":"Fix"},{"location":"changelog/#30-2022-09-05","text":"","title":"[3.0] - 2022-09-05"},{"location":"changelog/#added_3","text":"Flexible array support","title":"Added"},{"location":"changelog/#31-2022-09-13","text":"","title":"[3.1] - 2022-09-13"},{"location":"changelog/#added_4","text":"Make CStruct/MemCStruct Pickle Friendly","title":"Added"},{"location":"changelog/#32-2022-10-23","text":"","title":"[3.2] - 2022-10-23"},{"location":"changelog/#fix_7","text":"Fix padding tests on 32bit architectures","title":"Fix"},{"location":"changelog/#33-2022-10-24","text":"","title":"[3.3] - 2022-10-24"},{"location":"changelog/#added_5","text":"Add 32bit test environment","title":"Added"},{"location":"changelog/#fix_8","text":"Fix padding tests on 32bit architectures","title":"Fix"},{"location":"changelog/#40-2022-11-01","text":"","title":"[4.0] - 2022-11-01"},{"location":"changelog/#added_6","text":"Add support for nameless inline struct","title":"Added"},{"location":"changelog/#improved_7","text":"Python 3.11 support","title":"Improved"},{"location":"changelog/#50-2022-11-12","text":"","title":"[5.0] - 2022-11-12"},{"location":"changelog/#added_7","text":"Add support for enums Add support for multiple definition to cstruct.parse Add inspect method","title":"Added"},{"location":"changelog/#improved_8","text":"Documentation and examples Restructure setup","title":"Improved"},{"location":"changelog/#51-2022-11-20","text":"","title":"[5.1] - 2022-11-20"},{"location":"changelog/#improved_9","text":"Support unpack from ctype pointers","title":"Improved"},{"location":"changelog/#added_8","text":"Add support for char constants Add native type test dir.py example","title":"Added"},{"location":"changelog/#52-2022-11-23","text":"","title":"[5.2] - 2022-11-23"},{"location":"changelog/#fix_9","text":"nested struct unpack fix nested anonymous union offset fix inspect offset for nested struct/union fix","title":"Fix"},{"location":"changelog/#53-2024-01-08","text":"","title":"[5.3] - 2024-01-08"},{"location":"changelog/#fix_10","text":"fix struct in struct array parsing","title":"Fix"},{"location":"changelog/#improved_10","text":"Python 3.12 support","title":"Improved"},{"location":"changelog/#60-2025-01-16","text":"","title":"[6.0] - 2025-01-16"},{"location":"changelog/#added_9","text":"access to Python class attributes in struct definition","title":"Added"},{"location":"changelog/#improved_11","text":"Python 3.13 support","title":"Improved"},{"location":"license/","text":"The MIT License (MIT) Copyright (c) 2013-2022 Andrea Bonomi andrea.bonomi@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/abstract/","text":"AbstractCEnum Bases: IntEnum Abstract C enum to Python class Source code in cstruct/abstract.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class AbstractCEnum ( IntEnum , metaclass = CEnumMeta ): \"\"\" Abstract C enum to Python class \"\"\" @classmethod def parse ( cls , __enum__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __size__ : Optional [ int ] = None , __native_format__ : Optional [ str ] = None , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCEnum\" ]: \"\"\" Return a new Python Enum class mapping a C enum definition Args: __enum__: Definition of the enum in C syntax __name__: Name of the new Enum. If empty, a name based on the __enum__ hash is generated __size__: Number of bytes that the enum should be read as __native_format__: struct module format Returns: cls: A new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __size__ is not None : cls_kargs [ \"__size__\" ] = __size__ if __native_format__ is not None : cls_kargs [ \"__native_format__\" ] = __native_format__ if isinstance ( __enum__ , ( str , Tokens )): cls_kargs . update ( parse_enum_def ( __enum__ , __cls__ = cls , ** cls_kargs )) elif isinstance ( __enum__ , dict ): cls_kargs . update ( __enum__ ) __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __enum__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs . update ( cls_kargs [ \"__constants__\" ]) return cls ( __name__ , cls_kargs ) parse ( __enum__ , __name__ = None , __size__ = None , __native_format__ = None , ** kargs ) classmethod Return a new Python Enum class mapping a C enum definition Parameters: __enum__ ( Union [ str , Tokens , Dict [ str , Any ]] ) \u2013 Definition of the enum in C syntax __name__ ( Optional [ str ] , default: None ) \u2013 Name of the new Enum. If empty, a name based on the enum hash is generated __size__ ( Optional [ int ] , default: None ) \u2013 Number of bytes that the enum should be read as __native_format__ ( Optional [ str ] , default: None ) \u2013 struct module format Returns: cls ( Type [ AbstractCEnum ] ) \u2013 A new class mapping the definition Source code in cstruct/abstract.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 @classmethod def parse ( cls , __enum__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __size__ : Optional [ int ] = None , __native_format__ : Optional [ str ] = None , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCEnum\" ]: \"\"\" Return a new Python Enum class mapping a C enum definition Args: __enum__: Definition of the enum in C syntax __name__: Name of the new Enum. If empty, a name based on the __enum__ hash is generated __size__: Number of bytes that the enum should be read as __native_format__: struct module format Returns: cls: A new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __size__ is not None : cls_kargs [ \"__size__\" ] = __size__ if __native_format__ is not None : cls_kargs [ \"__native_format__\" ] = __native_format__ if isinstance ( __enum__ , ( str , Tokens )): cls_kargs . update ( parse_enum_def ( __enum__ , __cls__ = cls , ** cls_kargs )) elif isinstance ( __enum__ , dict ): cls_kargs . update ( __enum__ ) __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __enum__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs . update ( cls_kargs [ \"__constants__\" ]) return cls ( __name__ , cls_kargs ) AbstractCStruct Abstract C struct to Python class Source code in cstruct/abstract.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 class AbstractCStruct ( metaclass = CStructMeta ): \"\"\" Abstract C struct to Python class \"\"\" __size__ : int = 0 \" Size in bytes \" __fields__ : List [ str ] = [] \" Struct/union fields \" __fields_types__ : Dict [ str , FieldType ] \" Dictionary mapping field names to types \" __byte_order__ : Optional [ str ] = None \" Byte order \" __alignment__ : int = 0 \" Alignment \" __is_union__ : bool = False \" True if the class is an union, False if it is a struct \" def __init__ ( self , buffer : Optional [ Union [ bytes , BinaryIO ]] = None , flexible_array_length : Optional [ int ] = None , ** kargs : Dict [ str , Any ] ) -> None : self . set_flexible_array_length ( flexible_array_length ) self . __fields__ = [ x for x in self . __fields__ ] # Create a copy self . __fields_types__ = OrderedDict ({ k : v . copy () for k , v in self . __fields_types__ . items ()}) # Create a copy if buffer is not None : self . unpack ( buffer ) else : try : self . unpack ( buffer ) except Exception : pass for key , value in kargs . items (): setattr ( self , key , value ) @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ \"__byte_order__\" ] = __byte_order__ if __is_union__ is not None : cls_kargs [ \"__is_union__\" ] = __is_union__ cls_kargs [ \"__struct__\" ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( parse_struct_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ \"__struct__\" ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( __struct__ ) cls_kargs [ \"__struct__\" ] = None __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : # Anonymous struct __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __struct__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs [ \"__name__\" ] = __name__ return type ( __name__ , ( cls ,), cls_kargs ) def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen_ex = flexible_array_length def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , \"read\" ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer ) def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError def pack_into ( self , buffer : bytearray , offset : int = 0 ) -> None : \"\"\" Pack the structure data into a buffer Args: buffer: target buffer (must be large enough to contain the packed structure) offset: optional buffer offset \"\"\" tmp = self . pack () buffer [ offset : offset + len ( tmp )] = tmp def clear ( self ) -> None : self . unpack ( None ) def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size @property def size ( self ) -> int : \"Actual structure size (in bytes)\" if not self . __fields_types__ : # no fields return 0 elif self . __is_union__ : # C union # Calculate the sizeof union as size of its largest element return max ( x . vsize for x in self . __fields_types__ . values ()) else : # C struct # Calculate the sizeof struct as last item's offset + size + padding last_field_type = list ( self . __fields_types__ . values ())[ - 1 ] size = last_field_type . offset + last_field_type . vsize padding = calculate_padding ( self . __byte_order__ , self . __alignment__ , size ) return size + padding @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__ def inspect ( self , start_addr : Optional [ int ] = None , end_addr : Optional [ int ] = None ) -> str : \"\"\" Return memory content in hexadecimal Args: start_addr: start address end_addr: end address \"\"\" buffer = StringIO () if hasattr ( self , \"__mem__\" ): mem = self . __mem__ [ self . __base__ :] else : mem = self . pack () if end_addr is None : end_addr = self . size for i in range ( start_addr or 0 , end_addr , 16 ): row = mem [ i : min ( i + 16 , end_addr )] buffer . write ( f \" { i : 08x } \" ) for j , c in enumerate ( row ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { c : 02x }{ separator } \" ) for j in range ( len ( row ) - 1 , 15 ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { separator } \" ) buffer . write ( \" |\" ) for c in row : buffer . write ( chr ( c ) if c >= 32 and c < 127 else \".\" ) for j in range ( len ( row ) - 1 , 15 ): buffer . write ( \" \" ) buffer . write ( \"|\" ) buffer . write ( \" \\n \" ) buffer . seek ( 0 , 0 ) return buffer . read () def __eq__ ( self , other : Any ) -> bool : return other is not None and isinstance ( other , self . __class__ ) and self . __dict__ == other . __dict__ def __ne__ ( self , other : Any ) -> bool : return not self . __eq__ ( other ) def __str__ ( self ) -> str : result = [] for field in self . __fields__ : result . append ( field + \"=\" + str ( getattr ( self , field , None ))) return type ( self ) . __name__ + \"(\" + \", \" . join ( result ) + \")\" def __repr__ ( self ) -> str : # pragma: no cover return self . __str__ () def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack () def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state ) __alignment__ : int = 0 class-attribute instance-attribute Alignment __byte_order__ : Optional [ str ] = None class-attribute instance-attribute Byte order __fields__ : List [ str ] = [ x for x in self . __fields__ ] class-attribute instance-attribute Struct/union fields __fields_types__ : Dict [ str , FieldType ] = OrderedDict ({ k : v . copy () for ( k , v ) in self . __fields_types__ . items ()}) instance-attribute Dictionary mapping field names to types __is_union__ : bool = False class-attribute instance-attribute True if the class is an union, False if it is a struct __size__ : int = 0 class-attribute instance-attribute Size in bytes size : int property Actual structure size (in bytes) __getstate__ () This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/abstract.py 290 291 292 293 294 295 296 297 298 299 def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack () __len__ () Actual structure size (in bytes) Source code in cstruct/abstract.py 217 218 219 def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size __setstate__ ( state ) This method it is called with the unpickled state Parameters: state ( bytes ) \u2013 bytes to be unpacked Source code in cstruct/abstract.py 301 302 303 304 305 306 307 308 def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state ) inspect ( start_addr = None , end_addr = None ) Return memory content in hexadecimal Parameters: start_addr ( Optional [ int ] , default: None ) \u2013 start address end_addr ( Optional [ int ] , default: None ) \u2013 end address Source code in cstruct/abstract.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def inspect ( self , start_addr : Optional [ int ] = None , end_addr : Optional [ int ] = None ) -> str : \"\"\" Return memory content in hexadecimal Args: start_addr: start address end_addr: end address \"\"\" buffer = StringIO () if hasattr ( self , \"__mem__\" ): mem = self . __mem__ [ self . __base__ :] else : mem = self . pack () if end_addr is None : end_addr = self . size for i in range ( start_addr or 0 , end_addr , 16 ): row = mem [ i : min ( i + 16 , end_addr )] buffer . write ( f \" { i : 08x } \" ) for j , c in enumerate ( row ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { c : 02x }{ separator } \" ) for j in range ( len ( row ) - 1 , 15 ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { separator } \" ) buffer . write ( \" |\" ) for c in row : buffer . write ( chr ( c ) if c >= 32 and c < 127 else \".\" ) for j in range ( len ( row ) - 1 , 15 ): buffer . write ( \" \" ) buffer . write ( \"|\" ) buffer . write ( \" \\n \" ) buffer . seek ( 0 , 0 ) return buffer . read () pack () Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/abstract.py 194 195 196 197 198 199 200 201 def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError pack_into ( buffer , offset = 0 ) Pack the structure data into a buffer Parameters: buffer ( bytearray ) \u2013 target buffer (must be large enough to contain the packed structure) offset ( int , default: 0 ) \u2013 optional buffer offset Source code in cstruct/abstract.py 203 204 205 206 207 208 209 210 211 212 def pack_into ( self , buffer : bytearray , offset : int = 0 ) -> None : \"\"\" Pack the structure data into a buffer Args: buffer: target buffer (must be large enough to contain the packed structure) offset: optional buffer offset \"\"\" tmp = self . pack () buffer [ offset : offset + len ( tmp )] = tmp parse ( __struct__ , __name__ = None , __byte_order__ = None , __is_union__ = False , ** kargs ) classmethod Return a new class mapping a C struct/union definition. Parameters: __struct__ ( Union [ str , Tokens , Dict [ str , Any ]] ) \u2013 definition of the struct (or union) in C syntax __name__ ( Optional [ str ] , default: None ) \u2013 name of the new class. If empty, a name based on the struct hash is generated __byte_order__ ( Optional [ str ] , default: None ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( Optional [ bool ] , default: False ) \u2013 True for union, False for struct Returns: cls ( Type [ AbstractCStruct ] ) \u2013 a new class mapping the definition Source code in cstruct/abstract.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ \"__byte_order__\" ] = __byte_order__ if __is_union__ is not None : cls_kargs [ \"__is_union__\" ] = __is_union__ cls_kargs [ \"__struct__\" ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( parse_struct_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ \"__struct__\" ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( __struct__ ) cls_kargs [ \"__struct__\" ] = None __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : # Anonymous struct __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __struct__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs [ \"__name__\" ] = __name__ return type ( __name__ , ( cls ,), cls_kargs ) set_flexible_array_length ( flexible_array_length ) Set flexible array length (i.e. number of elements) Parameters: flexible_array_length ( Optional [ int ] ) \u2013 flexible array length Raises: CStructException \u2013 If flexible array is not present in the structure Source code in cstruct/abstract.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen_ex = flexible_array_length sizeof () classmethod Structure size in bytes (flexible array member size is omitted) Source code in cstruct/abstract.py 236 237 238 239 @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__ unpack ( buffer , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ Union [ bytes , BinaryIO ]] ) \u2013 bytes or binary stream to be unpacked flexible_array_length ( Optional [ int ] , default: None ) \u2013 flexible array length Source code in cstruct/abstract.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , \"read\" ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer ) unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 flexible array length Source code in cstruct/abstract.py 181 182 183 184 185 186 187 188 189 190 191 192 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError CEnumMeta Bases: EnumMeta Source code in cstruct/abstract.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 class CEnumMeta ( EnumMeta ): __size__ : int __native_format__ : str class WrapperDict ( _EnumDict ): def __setitem__ ( self , key : str , value : Any ) -> None : env = None if key == \"__enum__\" : env = parse_enum ( value ) elif key == \"__def__\" : env = parse_enum_def ( value ) if env is not None : # register the enum constants in the object namespace, # using the Python Enum class Namespace dict that does the # heavy lifting for k , v in env [ \"__constants__\" ] . items (): super () . __setitem__ ( k , v ) else : return super () . __setitem__ ( key , value ) @classmethod def __prepare__ ( metacls , cls , bases , ** kwds ): namespace = EnumMeta . __prepare__ ( cls , bases , ** kwds ) namespace . __class__ = metacls . WrapperDict return namespace def __new__ ( metacls : Type [ \"CEnumMeta\" ], cls : str , bases : Tuple [ Type , ... ], classdict : _EnumDict , ** kwds : Any ) -> \"CEnumMeta\" : inst = super () . __new__ ( metacls , cls , bases , classdict , ** kwds ) if len ( inst ) > 0 : if classdict . get ( \"__native_format__\" ): # data type specified inst . __size__ = struct . calcsize ( classdict [ \"__native_format__\" ]) elif \"__size__\" in classdict : # size specified try : inst . __native_format__ = get_native_type ( ENUM_SIZE_TO_C_TYPE [ inst . __size__ ]) . native_format except KeyError : raise ParserError ( f \"Enum has invalid size. Needs to be in { ENUM_SIZE_TO_C_TYPE . keys () } \" ) else : # default inst . __size__ = DEFAULT_ENUM_SIZE inst . __native_format__ = get_native_type ( ENUM_SIZE_TO_C_TYPE [ inst . __size__ ]) . native_format print ( f \"Warning: __size__ not specified for enum { cls } . Will default to { DEFAULT_ENUM_SIZE } bytes\" ) if not classdict . get ( \"__anonymous__\" , False ): ENUMS [ cls ] = inst return inst @property def size ( cls ) -> int : \"Enum size (in bytes)\" return cls . __size__ size : int property Enum size (in bytes) CStructMeta Bases: ABCMeta Source code in cstruct/abstract.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class CStructMeta ( ABCMeta ): __size__ : int = 0 def __new__ ( metacls : Type [ type ], name : str , bases : Tuple [ str ], namespace : Dict [ str , Any ]) -> Type [ Any ]: __struct__ = namespace . get ( \"__struct__\" , None ) namespace [ \"__cls__\" ] = bases [ 0 ] if bases else None # Parse the struct if \"__struct__\" in namespace : if isinstance ( namespace [ \"__struct__\" ], ( str , Tokens )): namespace . update ( parse_struct ( ** namespace )) __struct__ = True if \"__def__\" in namespace : namespace . update ( parse_struct_def ( ** namespace )) __struct__ = True # Create the new class new_class : Type [ Any ] = super () . __new__ ( metacls , name , bases , namespace ) # Register the class if __struct__ is not None and not namespace . get ( \"__anonymous__\" ): STRUCTS [ name ] = new_class return new_class def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ @property def size ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ size : int property Structure size (in bytes) __len__ () Structure size (in bytes) Source code in cstruct/abstract.py 63 64 65 def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"cstruct.abstract"},{"location":"api/abstract/#cstruct.abstract.AbstractCEnum","text":"Bases: IntEnum Abstract C enum to Python class Source code in cstruct/abstract.py 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 class AbstractCEnum ( IntEnum , metaclass = CEnumMeta ): \"\"\" Abstract C enum to Python class \"\"\" @classmethod def parse ( cls , __enum__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __size__ : Optional [ int ] = None , __native_format__ : Optional [ str ] = None , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCEnum\" ]: \"\"\" Return a new Python Enum class mapping a C enum definition Args: __enum__: Definition of the enum in C syntax __name__: Name of the new Enum. If empty, a name based on the __enum__ hash is generated __size__: Number of bytes that the enum should be read as __native_format__: struct module format Returns: cls: A new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __size__ is not None : cls_kargs [ \"__size__\" ] = __size__ if __native_format__ is not None : cls_kargs [ \"__native_format__\" ] = __native_format__ if isinstance ( __enum__ , ( str , Tokens )): cls_kargs . update ( parse_enum_def ( __enum__ , __cls__ = cls , ** cls_kargs )) elif isinstance ( __enum__ , dict ): cls_kargs . update ( __enum__ ) __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __enum__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs . update ( cls_kargs [ \"__constants__\" ]) return cls ( __name__ , cls_kargs )","title":"AbstractCEnum"},{"location":"api/abstract/#cstruct.abstract.AbstractCEnum.parse","text":"Return a new Python Enum class mapping a C enum definition Parameters: __enum__ ( Union [ str , Tokens , Dict [ str , Any ]] ) \u2013 Definition of the enum in C syntax __name__ ( Optional [ str ] , default: None ) \u2013 Name of the new Enum. If empty, a name based on the enum hash is generated __size__ ( Optional [ int ] , default: None ) \u2013 Number of bytes that the enum should be read as __native_format__ ( Optional [ str ] , default: None ) \u2013 struct module format Returns: cls ( Type [ AbstractCEnum ] ) \u2013 A new class mapping the definition Source code in cstruct/abstract.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 @classmethod def parse ( cls , __enum__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __size__ : Optional [ int ] = None , __native_format__ : Optional [ str ] = None , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCEnum\" ]: \"\"\" Return a new Python Enum class mapping a C enum definition Args: __enum__: Definition of the enum in C syntax __name__: Name of the new Enum. If empty, a name based on the __enum__ hash is generated __size__: Number of bytes that the enum should be read as __native_format__: struct module format Returns: cls: A new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __size__ is not None : cls_kargs [ \"__size__\" ] = __size__ if __native_format__ is not None : cls_kargs [ \"__native_format__\" ] = __native_format__ if isinstance ( __enum__ , ( str , Tokens )): cls_kargs . update ( parse_enum_def ( __enum__ , __cls__ = cls , ** cls_kargs )) elif isinstance ( __enum__ , dict ): cls_kargs . update ( __enum__ ) __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __enum__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs . update ( cls_kargs [ \"__constants__\" ]) return cls ( __name__ , cls_kargs )","title":"parse"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct","text":"Abstract C struct to Python class Source code in cstruct/abstract.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 class AbstractCStruct ( metaclass = CStructMeta ): \"\"\" Abstract C struct to Python class \"\"\" __size__ : int = 0 \" Size in bytes \" __fields__ : List [ str ] = [] \" Struct/union fields \" __fields_types__ : Dict [ str , FieldType ] \" Dictionary mapping field names to types \" __byte_order__ : Optional [ str ] = None \" Byte order \" __alignment__ : int = 0 \" Alignment \" __is_union__ : bool = False \" True if the class is an union, False if it is a struct \" def __init__ ( self , buffer : Optional [ Union [ bytes , BinaryIO ]] = None , flexible_array_length : Optional [ int ] = None , ** kargs : Dict [ str , Any ] ) -> None : self . set_flexible_array_length ( flexible_array_length ) self . __fields__ = [ x for x in self . __fields__ ] # Create a copy self . __fields_types__ = OrderedDict ({ k : v . copy () for k , v in self . __fields_types__ . items ()}) # Create a copy if buffer is not None : self . unpack ( buffer ) else : try : self . unpack ( buffer ) except Exception : pass for key , value in kargs . items (): setattr ( self , key , value ) @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ \"__byte_order__\" ] = __byte_order__ if __is_union__ is not None : cls_kargs [ \"__is_union__\" ] = __is_union__ cls_kargs [ \"__struct__\" ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( parse_struct_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ \"__struct__\" ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( __struct__ ) cls_kargs [ \"__struct__\" ] = None __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : # Anonymous struct __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __struct__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs [ \"__name__\" ] = __name__ return type ( __name__ , ( cls ,), cls_kargs ) def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen_ex = flexible_array_length def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , \"read\" ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer ) def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError def pack_into ( self , buffer : bytearray , offset : int = 0 ) -> None : \"\"\" Pack the structure data into a buffer Args: buffer: target buffer (must be large enough to contain the packed structure) offset: optional buffer offset \"\"\" tmp = self . pack () buffer [ offset : offset + len ( tmp )] = tmp def clear ( self ) -> None : self . unpack ( None ) def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size @property def size ( self ) -> int : \"Actual structure size (in bytes)\" if not self . __fields_types__ : # no fields return 0 elif self . __is_union__ : # C union # Calculate the sizeof union as size of its largest element return max ( x . vsize for x in self . __fields_types__ . values ()) else : # C struct # Calculate the sizeof struct as last item's offset + size + padding last_field_type = list ( self . __fields_types__ . values ())[ - 1 ] size = last_field_type . offset + last_field_type . vsize padding = calculate_padding ( self . __byte_order__ , self . __alignment__ , size ) return size + padding @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__ def inspect ( self , start_addr : Optional [ int ] = None , end_addr : Optional [ int ] = None ) -> str : \"\"\" Return memory content in hexadecimal Args: start_addr: start address end_addr: end address \"\"\" buffer = StringIO () if hasattr ( self , \"__mem__\" ): mem = self . __mem__ [ self . __base__ :] else : mem = self . pack () if end_addr is None : end_addr = self . size for i in range ( start_addr or 0 , end_addr , 16 ): row = mem [ i : min ( i + 16 , end_addr )] buffer . write ( f \" { i : 08x } \" ) for j , c in enumerate ( row ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { c : 02x }{ separator } \" ) for j in range ( len ( row ) - 1 , 15 ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { separator } \" ) buffer . write ( \" |\" ) for c in row : buffer . write ( chr ( c ) if c >= 32 and c < 127 else \".\" ) for j in range ( len ( row ) - 1 , 15 ): buffer . write ( \" \" ) buffer . write ( \"|\" ) buffer . write ( \" \\n \" ) buffer . seek ( 0 , 0 ) return buffer . read () def __eq__ ( self , other : Any ) -> bool : return other is not None and isinstance ( other , self . __class__ ) and self . __dict__ == other . __dict__ def __ne__ ( self , other : Any ) -> bool : return not self . __eq__ ( other ) def __str__ ( self ) -> str : result = [] for field in self . __fields__ : result . append ( field + \"=\" + str ( getattr ( self , field , None ))) return type ( self ) . __name__ + \"(\" + \", \" . join ( result ) + \")\" def __repr__ ( self ) -> str : # pragma: no cover return self . __str__ () def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack () def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state )","title":"AbstractCStruct"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__alignment__","text":"Alignment","title":"__alignment__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__byte_order__","text":"Byte order","title":"__byte_order__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__fields__","text":"Struct/union fields","title":"__fields__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__fields_types__","text":"Dictionary mapping field names to types","title":"__fields_types__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__is_union__","text":"True if the class is an union, False if it is a struct","title":"__is_union__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__size__","text":"Size in bytes","title":"__size__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.size","text":"Actual structure size (in bytes)","title":"size"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__getstate__","text":"This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/abstract.py 290 291 292 293 294 295 296 297 298 299 def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack ()","title":"__getstate__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__len__","text":"Actual structure size (in bytes) Source code in cstruct/abstract.py 217 218 219 def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size","title":"__len__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__setstate__","text":"This method it is called with the unpickled state Parameters: state ( bytes ) \u2013 bytes to be unpacked Source code in cstruct/abstract.py 301 302 303 304 305 306 307 308 def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state )","title":"__setstate__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.inspect","text":"Return memory content in hexadecimal Parameters: start_addr ( Optional [ int ] , default: None ) \u2013 start address end_addr ( Optional [ int ] , default: None ) \u2013 end address Source code in cstruct/abstract.py 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def inspect ( self , start_addr : Optional [ int ] = None , end_addr : Optional [ int ] = None ) -> str : \"\"\" Return memory content in hexadecimal Args: start_addr: start address end_addr: end address \"\"\" buffer = StringIO () if hasattr ( self , \"__mem__\" ): mem = self . __mem__ [ self . __base__ :] else : mem = self . pack () if end_addr is None : end_addr = self . size for i in range ( start_addr or 0 , end_addr , 16 ): row = mem [ i : min ( i + 16 , end_addr )] buffer . write ( f \" { i : 08x } \" ) for j , c in enumerate ( row ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { c : 02x }{ separator } \" ) for j in range ( len ( row ) - 1 , 15 ): separator = \" \" if j == 7 else \"\" buffer . write ( f \" { separator } \" ) buffer . write ( \" |\" ) for c in row : buffer . write ( chr ( c ) if c >= 32 and c < 127 else \".\" ) for j in range ( len ( row ) - 1 , 15 ): buffer . write ( \" \" ) buffer . write ( \"|\" ) buffer . write ( \" \\n \" ) buffer . seek ( 0 , 0 ) return buffer . read ()","title":"inspect"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.pack","text":"Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/abstract.py 194 195 196 197 198 199 200 201 def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError","title":"pack"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.pack_into","text":"Pack the structure data into a buffer Parameters: buffer ( bytearray ) \u2013 target buffer (must be large enough to contain the packed structure) offset ( int , default: 0 ) \u2013 optional buffer offset Source code in cstruct/abstract.py 203 204 205 206 207 208 209 210 211 212 def pack_into ( self , buffer : bytearray , offset : int = 0 ) -> None : \"\"\" Pack the structure data into a buffer Args: buffer: target buffer (must be large enough to contain the packed structure) offset: optional buffer offset \"\"\" tmp = self . pack () buffer [ offset : offset + len ( tmp )] = tmp","title":"pack_into"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.parse","text":"Return a new class mapping a C struct/union definition. Parameters: __struct__ ( Union [ str , Tokens , Dict [ str , Any ]] ) \u2013 definition of the struct (or union) in C syntax __name__ ( Optional [ str ] , default: None ) \u2013 name of the new class. If empty, a name based on the struct hash is generated __byte_order__ ( Optional [ str ] , default: None ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( Optional [ bool ] , default: False ) \u2013 True for union, False for struct Returns: cls ( Type [ AbstractCStruct ] ) \u2013 a new class mapping the definition Source code in cstruct/abstract.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ], ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the definition \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ \"__byte_order__\" ] = __byte_order__ if __is_union__ is not None : cls_kargs [ \"__is_union__\" ] = __is_union__ cls_kargs [ \"__struct__\" ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( parse_struct_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ \"__struct__\" ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ \"__struct__\" ] cls_kargs . update ( __struct__ ) cls_kargs [ \"__struct__\" ] = None __name__ = cls_kargs . get ( \"__name__\" ) or __name__ if __name__ is None : # Anonymous struct __name__ = cls . __name__ + \"_\" + hashlib . sha1 ( str ( __struct__ ) . encode ( \"utf-8\" )) . hexdigest () cls_kargs [ \"__anonymous__\" ] = True cls_kargs [ \"__name__\" ] = __name__ return type ( __name__ , ( cls ,), cls_kargs )","title":"parse"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.set_flexible_array_length","text":"Set flexible array length (i.e. number of elements) Parameters: flexible_array_length ( Optional [ int ] ) \u2013 flexible array length Raises: CStructException \u2013 If flexible array is not present in the structure Source code in cstruct/abstract.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen_ex = flexible_array_length","title":"set_flexible_array_length"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.sizeof","text":"Structure size in bytes (flexible array member size is omitted) Source code in cstruct/abstract.py 236 237 238 239 @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__","title":"sizeof"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.unpack","text":"Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ Union [ bytes , BinaryIO ]] ) \u2013 bytes or binary stream to be unpacked flexible_array_length ( Optional [ int ] , default: None ) \u2013 flexible array length Source code in cstruct/abstract.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , \"read\" ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer )","title":"unpack"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 flexible array length Source code in cstruct/abstract.py 181 182 183 184 185 186 187 188 189 190 191 192 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError","title":"unpack_from"},{"location":"api/abstract/#cstruct.abstract.CEnumMeta","text":"Bases: EnumMeta Source code in cstruct/abstract.py 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 class CEnumMeta ( EnumMeta ): __size__ : int __native_format__ : str class WrapperDict ( _EnumDict ): def __setitem__ ( self , key : str , value : Any ) -> None : env = None if key == \"__enum__\" : env = parse_enum ( value ) elif key == \"__def__\" : env = parse_enum_def ( value ) if env is not None : # register the enum constants in the object namespace, # using the Python Enum class Namespace dict that does the # heavy lifting for k , v in env [ \"__constants__\" ] . items (): super () . __setitem__ ( k , v ) else : return super () . __setitem__ ( key , value ) @classmethod def __prepare__ ( metacls , cls , bases , ** kwds ): namespace = EnumMeta . __prepare__ ( cls , bases , ** kwds ) namespace . __class__ = metacls . WrapperDict return namespace def __new__ ( metacls : Type [ \"CEnumMeta\" ], cls : str , bases : Tuple [ Type , ... ], classdict : _EnumDict , ** kwds : Any ) -> \"CEnumMeta\" : inst = super () . __new__ ( metacls , cls , bases , classdict , ** kwds ) if len ( inst ) > 0 : if classdict . get ( \"__native_format__\" ): # data type specified inst . __size__ = struct . calcsize ( classdict [ \"__native_format__\" ]) elif \"__size__\" in classdict : # size specified try : inst . __native_format__ = get_native_type ( ENUM_SIZE_TO_C_TYPE [ inst . __size__ ]) . native_format except KeyError : raise ParserError ( f \"Enum has invalid size. Needs to be in { ENUM_SIZE_TO_C_TYPE . keys () } \" ) else : # default inst . __size__ = DEFAULT_ENUM_SIZE inst . __native_format__ = get_native_type ( ENUM_SIZE_TO_C_TYPE [ inst . __size__ ]) . native_format print ( f \"Warning: __size__ not specified for enum { cls } . Will default to { DEFAULT_ENUM_SIZE } bytes\" ) if not classdict . get ( \"__anonymous__\" , False ): ENUMS [ cls ] = inst return inst @property def size ( cls ) -> int : \"Enum size (in bytes)\" return cls . __size__","title":"CEnumMeta"},{"location":"api/abstract/#cstruct.abstract.CEnumMeta.size","text":"Enum size (in bytes)","title":"size"},{"location":"api/abstract/#cstruct.abstract.CStructMeta","text":"Bases: ABCMeta Source code in cstruct/abstract.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class CStructMeta ( ABCMeta ): __size__ : int = 0 def __new__ ( metacls : Type [ type ], name : str , bases : Tuple [ str ], namespace : Dict [ str , Any ]) -> Type [ Any ]: __struct__ = namespace . get ( \"__struct__\" , None ) namespace [ \"__cls__\" ] = bases [ 0 ] if bases else None # Parse the struct if \"__struct__\" in namespace : if isinstance ( namespace [ \"__struct__\" ], ( str , Tokens )): namespace . update ( parse_struct ( ** namespace )) __struct__ = True if \"__def__\" in namespace : namespace . update ( parse_struct_def ( ** namespace )) __struct__ = True # Create the new class new_class : Type [ Any ] = super () . __new__ ( metacls , name , bases , namespace ) # Register the class if __struct__ is not None and not namespace . get ( \"__anonymous__\" ): STRUCTS [ name ] = new_class return new_class def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ @property def size ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"CStructMeta"},{"location":"api/abstract/#cstruct.abstract.CStructMeta.size","text":"Structure size (in bytes)","title":"size"},{"location":"api/abstract/#cstruct.abstract.CStructMeta.__len__","text":"Structure size (in bytes) Source code in cstruct/abstract.py 63 64 65 def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"__len__"},{"location":"api/base/","text":"BIG_ENDIAN = '>' module-attribute Big-endian, std. size & alignment LITTLE_ENDIAN = '<' module-attribute Little-endian, std. size & alignment NATIVE_ORDER = '@' module-attribute Native order, size & alignment","title":"cstruct.base"},{"location":"api/base/#cstruct.base.BIG_ENDIAN","text":"Big-endian, std. size & alignment","title":"BIG_ENDIAN"},{"location":"api/base/#cstruct.base.LITTLE_ENDIAN","text":"Little-endian, std. size & alignment","title":"LITTLE_ENDIAN"},{"location":"api/base/#cstruct.base.NATIVE_ORDER","text":"Native order, size & alignment","title":"NATIVE_ORDER"},{"location":"api/c_expr/","text":"c_eval ( expr ) Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval ( '10 + (5 / 3)' ) 11 >>> c_eval ( '!0' ) 1 >>> c_eval ( 'sizeof(x)' ) 128 Parameters: expr ( str ) \u2013 C expression Returns: result ( Union [ int , float ] ) \u2013 the expression evaluation result Raises: EvalError \u2013 expression evaluation error Source code in cstruct/c_expr.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def c_eval ( expr : str ) -> Union [ int , float ]: \"\"\" Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval('10 + (5 / 3)') 11 >>> c_eval('!0') 1 >>> c_eval('sizeof(x)') 128 Args: expr: C expression Returns: result: the expression evaluation result Raises: EvalError: expression evaluation error \"\"\" try : expr = expr . replace ( \"!\" , \" not \" ) . replace ( \"&&\" , \" and \" ) . replace ( \"||\" , \" or \" ) return eval_node ( ast . parse ( expr . strip ()) . body [ 0 ]) except EvalError : raise except Exception : raise EvalError eval_attribute_node ( node ) Evaluate node attribute, e.g. 'self.x' Only 'self' is allowed. The attribute must be a number. Parameters: node ( Attribute ) \u2013 attribute node Returns: result ( Union [ int , float ] ) \u2013 the attribute value Raises: EvalError \u2013 expression result is not a number, or not self attribute ContextNotFound \u2013 context is not defined Source code in cstruct/c_expr.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def eval_attribute_node ( node : ast . Attribute ) -> Union [ int , float ]: \"\"\" Evaluate node attribute, e.g. 'self.x' Only 'self' is allowed. The attribute must be a number. Args: node: attribute node Returns: result: the attribute value Raises: EvalError: expression result is not a number, or not self attribute ContextNotFound: context is not defined \"\"\" if not node . value or node . value . id != \"self\" : # type: ignore raise EvalError ( \"only self is allowed\" ) context = get_cstruct_context () if context is None : raise ContextNotFound ( \"context is not defined\" ) result = getattr ( context , node . attr ) if not isinstance ( result , ( int , float )): raise EvalError ( \"expression result is not a number\" ) return result eval_compare ( node ) Evaluate a compare node Source code in cstruct/c_expr.py 119 120 121 122 123 124 125 126 127 def eval_compare ( node ) -> bool : \"Evaluate a compare node\" right = eval_node ( node . left ) for operation , comp in zip ( node . ops , node . comparators ): left = right right = eval_node ( comp ) if not OPS [ type ( operation )]( left , right ): return False return True eval_div ( node ) Evaluate div node (integer/float) Source code in cstruct/c_expr.py 130 131 132 133 134 135 136 137 def eval_div ( node ) -> Union [ int , float ]: \"Evaluate div node (integer/float)\" left = eval_node ( node . left ) right = eval_node ( node . right ) if isinstance ( left , float ) or isinstance ( right , float ): return operator . truediv ( left , right ) else : return operator . floordiv ( left , right ) eval_get ( node ) Get definition/struct by name Source code in cstruct/c_expr.py 111 112 113 114 115 116 def eval_get ( node ) -> Union [ int , float , Type [ \"AbstractCStruct\" ]]: \"Get definition/struct by name\" try : return DEFINES [ node . id ] except KeyError : return STRUCTS [ node . id ] get_cstruct_context () Get the calling CStruct instance from the stack (if any) Source code in cstruct/c_expr.py 149 150 151 152 153 154 155 156 157 158 159 160 def get_cstruct_context () -> Optional [ \"AbstractCStruct\" ]: \"\"\" Get the calling CStruct instance from the stack (if any) \"\"\" from .abstract import AbstractCStruct stack = inspect . stack () for frame in stack : caller_self = frame . frame . f_locals . get ( \"self\" ) if isinstance ( caller_self , AbstractCStruct ): return caller_self return None","title":"cstruct.c_expr"},{"location":"api/c_expr/#cstruct.c_expr.c_eval","text":"Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval ( '10 + (5 / 3)' ) 11 >>> c_eval ( '!0' ) 1 >>> c_eval ( 'sizeof(x)' ) 128 Parameters: expr ( str ) \u2013 C expression Returns: result ( Union [ int , float ] ) \u2013 the expression evaluation result Raises: EvalError \u2013 expression evaluation error Source code in cstruct/c_expr.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def c_eval ( expr : str ) -> Union [ int , float ]: \"\"\" Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval('10 + (5 / 3)') 11 >>> c_eval('!0') 1 >>> c_eval('sizeof(x)') 128 Args: expr: C expression Returns: result: the expression evaluation result Raises: EvalError: expression evaluation error \"\"\" try : expr = expr . replace ( \"!\" , \" not \" ) . replace ( \"&&\" , \" and \" ) . replace ( \"||\" , \" or \" ) return eval_node ( ast . parse ( expr . strip ()) . body [ 0 ]) except EvalError : raise except Exception : raise EvalError","title":"c_eval"},{"location":"api/c_expr/#cstruct.c_expr.eval_attribute_node","text":"Evaluate node attribute, e.g. 'self.x' Only 'self' is allowed. The attribute must be a number. Parameters: node ( Attribute ) \u2013 attribute node Returns: result ( Union [ int , float ] ) \u2013 the attribute value Raises: EvalError \u2013 expression result is not a number, or not self attribute ContextNotFound \u2013 context is not defined Source code in cstruct/c_expr.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def eval_attribute_node ( node : ast . Attribute ) -> Union [ int , float ]: \"\"\" Evaluate node attribute, e.g. 'self.x' Only 'self' is allowed. The attribute must be a number. Args: node: attribute node Returns: result: the attribute value Raises: EvalError: expression result is not a number, or not self attribute ContextNotFound: context is not defined \"\"\" if not node . value or node . value . id != \"self\" : # type: ignore raise EvalError ( \"only self is allowed\" ) context = get_cstruct_context () if context is None : raise ContextNotFound ( \"context is not defined\" ) result = getattr ( context , node . attr ) if not isinstance ( result , ( int , float )): raise EvalError ( \"expression result is not a number\" ) return result","title":"eval_attribute_node"},{"location":"api/c_expr/#cstruct.c_expr.eval_compare","text":"Evaluate a compare node Source code in cstruct/c_expr.py 119 120 121 122 123 124 125 126 127 def eval_compare ( node ) -> bool : \"Evaluate a compare node\" right = eval_node ( node . left ) for operation , comp in zip ( node . ops , node . comparators ): left = right right = eval_node ( comp ) if not OPS [ type ( operation )]( left , right ): return False return True","title":"eval_compare"},{"location":"api/c_expr/#cstruct.c_expr.eval_div","text":"Evaluate div node (integer/float) Source code in cstruct/c_expr.py 130 131 132 133 134 135 136 137 def eval_div ( node ) -> Union [ int , float ]: \"Evaluate div node (integer/float)\" left = eval_node ( node . left ) right = eval_node ( node . right ) if isinstance ( left , float ) or isinstance ( right , float ): return operator . truediv ( left , right ) else : return operator . floordiv ( left , right )","title":"eval_div"},{"location":"api/c_expr/#cstruct.c_expr.eval_get","text":"Get definition/struct by name Source code in cstruct/c_expr.py 111 112 113 114 115 116 def eval_get ( node ) -> Union [ int , float , Type [ \"AbstractCStruct\" ]]: \"Get definition/struct by name\" try : return DEFINES [ node . id ] except KeyError : return STRUCTS [ node . id ]","title":"eval_get"},{"location":"api/c_expr/#cstruct.c_expr.get_cstruct_context","text":"Get the calling CStruct instance from the stack (if any) Source code in cstruct/c_expr.py 149 150 151 152 153 154 155 156 157 158 159 160 def get_cstruct_context () -> Optional [ \"AbstractCStruct\" ]: \"\"\" Get the calling CStruct instance from the stack (if any) \"\"\" from .abstract import AbstractCStruct stack = inspect . stack () for frame in stack : caller_self = frame . frame . f_locals . get ( \"self\" ) if isinstance ( caller_self , AbstractCStruct ): return caller_self return None","title":"get_cstruct_context"},{"location":"api/c_parser/","text":"parse_enum ( __enum__ , __name__ = None , native_format = None , ** kargs ) Parser for C-like enum syntax. Parameters: __enum__ ( Union [ str , Tokens ] ) \u2013 definition of the enum in C syntax __name__ ( Optional [ str ] , default: None ) \u2013 enum name native_format ( Optional [ str ] , default: None ) \u2013 struct module format Returns: dict ( Optional [ Dict [ str , Any ]] ) \u2013 the parsed definition Source code in cstruct/c_parser.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def parse_enum ( __enum__ : Union [ str , Tokens ], __name__ : Optional [ str ] = None , native_format : Optional [ str ] = None , ** kargs : Any , ) -> Optional [ Dict [ str , Any ]]: \"\"\" Parser for C-like enum syntax. Args: __enum__: definition of the enum in C syntax __name__: enum name native_format: struct module format Returns: dict: the parsed definition \"\"\" from .cenum import CEnum constants : Dict [ str , int ] = OrderedDict () if isinstance ( __enum__ , Tokens ): tokens = __enum__ else : tokens = Tokens ( __enum__ ) while len ( tokens ): if tokens . get () == \"}\" : tokens . pop () break name = tokens . pop () next_token = tokens . pop () if next_token in { \",\" , \"}\" }: # enum-constant without explicit value if len ( constants ) == 0 : value = 0 else : value = next ( reversed ( constants . values ())) + 1 elif next_token == \"=\" : # enum-constant with explicit value exp_elems = [] next_token = tokens . pop () while next_token not in { \",\" , \"}\" }: exp_elems . append ( next_token ) if len ( tokens ) > 0 : next_token = tokens . pop () else : break if len ( exp_elems ) == 0 : raise ParserError ( \"enum is missing value expression\" ) int_expr = \" \" . join ( exp_elems ) try : value = c_eval ( int_expr ) except ( ValueError , TypeError ): value = int ( int_expr ) else : raise ParserError ( f \"` { __enum__ } ` is not a valid enum expression\" ) if name in constants : raise ParserError ( f \"duplicate enum name ` { name } `\" ) constants [ name ] = value if next_token == \"}\" : break result = { \"__constants__\" : constants , \"__is_struct__\" : False , \"__is_union__\" : False , \"__is_enum__\" : True , \"__name__\" : __name__ , \"__native_format__\" : native_format , \"__cls__\" : CEnum , } return result parse_struct ( __struct__ , __cls__ , __is_union__ = False , __byte_order__ = None , __name__ = None , ** kargs ) Parser for C-like struct syntax. Parameters: __struct__ ( Union [ str , Tokens ] ) \u2013 definition of the struct/union in C syntax __cls__ ( Type [ AbstractCStruct ] ) \u2013 base class (MemCStruct or CStruct) __is_union__ ( bool , default: False ) \u2013 True for union, False for struct __byte_order__ ( Optional [ str ] , default: None ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __name__ ( Optional [ str ] , default: None ) \u2013 struct/union name Returns: dict ( Dict [ str , Any ] ) \u2013 the parsed definition Source code in cstruct/c_parser.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def parse_struct ( __struct__ : Union [ str , Tokens ], __cls__ : Type [ \"AbstractCStruct\" ], __is_union__ : bool = False , __byte_order__ : Optional [ str ] = None , __name__ : Optional [ str ] = None , ** kargs : Any , ) -> Dict [ str , Any ]: \"\"\" Parser for C-like struct syntax. Args: __struct__: definition of the struct/union in C syntax __cls__: base class (MemCStruct or CStruct) __is_union__: True for union, False for struct __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __name__: struct/union name Returns: dict: the parsed definition \"\"\" # naive C struct parsing from .abstract import AbstractCStruct from .mem_cstruct import MemCStruct if __cls__ is None or __cls__ == AbstractCStruct : __cls__ = MemCStruct __is_union__ = bool ( __is_union__ ) fields_types : Dict [ str , FieldType ] = OrderedDict () flexible_array : bool = False offset : int = 0 max_alignment : int = 0 anonymous : int = 0 if isinstance ( __struct__ , Tokens ): tokens = __struct__ else : tokens = Tokens ( __struct__ ) while len ( tokens ): if tokens . get () == \"}\" : tokens . pop () break # flexible array member must be the last member of such a struct if flexible_array : raise CStructException ( \"Flexible array member must be the last member of such a struct\" ) field_type = parse_type ( tokens , __cls__ , __byte_order__ , offset ) vname = tokens . pop () if vname in fields_types : raise ParserError ( f \"Duplicate member ` { vname } `\" ) if vname in dir ( __cls__ ): raise ParserError ( f \"Invalid reserved member name ` { vname } `\" ) # parse length if \"[\" in vname : vname , field_type . vlen_ex , field_type . flexible_array = parse_length ( tokens , vname , flexible_array ) flexible_array = flexible_array or field_type . flexible_array # anonymous nested union if vname == \";\" and field_type . ref is not None and ( __is_union__ or field_type . ref . __is_union__ ): # add the anonymous struct fields to the parent for nested_field_name , nested_field_type in field_type . ref . __fields_types__ . items (): if nested_field_name in fields_types : raise ParserError ( f \"Duplicate member ` { nested_field_name } `\" ) # set the correct offset nested_field_type = nested_field_type . copy () nested_field_type . base_offset = offset + nested_field_type . base_offset nested_field_type . offset = offset + nested_field_type . offset fields_types [ nested_field_name ] = nested_field_type vname = f \"__anonymous { anonymous } \" anonymous += 1 tokens . push ( \";\" ) fields_types [ vname ] = field_type # calculate the max field size (for the alignment) max_alignment = max ( max_alignment , field_type . alignment ) # align struct if byte order is native if not __is_union__ : # C struct field_type . align_filed_offset () offset = field_type . offset + field_type . vsize t = tokens . pop () if t != \";\" : raise ParserError ( f \"`;` expected but ` { t } ` found\" ) if __is_union__ : # C union # Calculate the sizeof union as size of its largest element size = max ([ x . vsize for x in fields_types . values ()]) else : # C struct # add padding to struct if byte order is native size = offset + calculate_padding ( __byte_order__ , max_alignment , offset ) # Prepare the result result = { \"__fields__\" : list ( fields_types . keys ()), \"__fields_types__\" : fields_types , \"__size__\" : size , \"__is_struct__\" : not __is_union__ , \"__is_union__\" : __is_union__ , \"__is_enum__\" : False , \"__byte_order__\" : __byte_order__ , \"__alignment__\" : max_alignment , \"__name__\" : __name__ , \"__cls__\" : __cls__ , } return result","title":"cstruct.c_parser"},{"location":"api/c_parser/#cstruct.c_parser.parse_enum","text":"Parser for C-like enum syntax. Parameters: __enum__ ( Union [ str , Tokens ] ) \u2013 definition of the enum in C syntax __name__ ( Optional [ str ] , default: None ) \u2013 enum name native_format ( Optional [ str ] , default: None ) \u2013 struct module format Returns: dict ( Optional [ Dict [ str , Any ]] ) \u2013 the parsed definition Source code in cstruct/c_parser.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def parse_enum ( __enum__ : Union [ str , Tokens ], __name__ : Optional [ str ] = None , native_format : Optional [ str ] = None , ** kargs : Any , ) -> Optional [ Dict [ str , Any ]]: \"\"\" Parser for C-like enum syntax. Args: __enum__: definition of the enum in C syntax __name__: enum name native_format: struct module format Returns: dict: the parsed definition \"\"\" from .cenum import CEnum constants : Dict [ str , int ] = OrderedDict () if isinstance ( __enum__ , Tokens ): tokens = __enum__ else : tokens = Tokens ( __enum__ ) while len ( tokens ): if tokens . get () == \"}\" : tokens . pop () break name = tokens . pop () next_token = tokens . pop () if next_token in { \",\" , \"}\" }: # enum-constant without explicit value if len ( constants ) == 0 : value = 0 else : value = next ( reversed ( constants . values ())) + 1 elif next_token == \"=\" : # enum-constant with explicit value exp_elems = [] next_token = tokens . pop () while next_token not in { \",\" , \"}\" }: exp_elems . append ( next_token ) if len ( tokens ) > 0 : next_token = tokens . pop () else : break if len ( exp_elems ) == 0 : raise ParserError ( \"enum is missing value expression\" ) int_expr = \" \" . join ( exp_elems ) try : value = c_eval ( int_expr ) except ( ValueError , TypeError ): value = int ( int_expr ) else : raise ParserError ( f \"` { __enum__ } ` is not a valid enum expression\" ) if name in constants : raise ParserError ( f \"duplicate enum name ` { name } `\" ) constants [ name ] = value if next_token == \"}\" : break result = { \"__constants__\" : constants , \"__is_struct__\" : False , \"__is_union__\" : False , \"__is_enum__\" : True , \"__name__\" : __name__ , \"__native_format__\" : native_format , \"__cls__\" : CEnum , } return result","title":"parse_enum"},{"location":"api/c_parser/#cstruct.c_parser.parse_struct","text":"Parser for C-like struct syntax. Parameters: __struct__ ( Union [ str , Tokens ] ) \u2013 definition of the struct/union in C syntax __cls__ ( Type [ AbstractCStruct ] ) \u2013 base class (MemCStruct or CStruct) __is_union__ ( bool , default: False ) \u2013 True for union, False for struct __byte_order__ ( Optional [ str ] , default: None ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __name__ ( Optional [ str ] , default: None ) \u2013 struct/union name Returns: dict ( Dict [ str , Any ] ) \u2013 the parsed definition Source code in cstruct/c_parser.py 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 def parse_struct ( __struct__ : Union [ str , Tokens ], __cls__ : Type [ \"AbstractCStruct\" ], __is_union__ : bool = False , __byte_order__ : Optional [ str ] = None , __name__ : Optional [ str ] = None , ** kargs : Any , ) -> Dict [ str , Any ]: \"\"\" Parser for C-like struct syntax. Args: __struct__: definition of the struct/union in C syntax __cls__: base class (MemCStruct or CStruct) __is_union__: True for union, False for struct __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __name__: struct/union name Returns: dict: the parsed definition \"\"\" # naive C struct parsing from .abstract import AbstractCStruct from .mem_cstruct import MemCStruct if __cls__ is None or __cls__ == AbstractCStruct : __cls__ = MemCStruct __is_union__ = bool ( __is_union__ ) fields_types : Dict [ str , FieldType ] = OrderedDict () flexible_array : bool = False offset : int = 0 max_alignment : int = 0 anonymous : int = 0 if isinstance ( __struct__ , Tokens ): tokens = __struct__ else : tokens = Tokens ( __struct__ ) while len ( tokens ): if tokens . get () == \"}\" : tokens . pop () break # flexible array member must be the last member of such a struct if flexible_array : raise CStructException ( \"Flexible array member must be the last member of such a struct\" ) field_type = parse_type ( tokens , __cls__ , __byte_order__ , offset ) vname = tokens . pop () if vname in fields_types : raise ParserError ( f \"Duplicate member ` { vname } `\" ) if vname in dir ( __cls__ ): raise ParserError ( f \"Invalid reserved member name ` { vname } `\" ) # parse length if \"[\" in vname : vname , field_type . vlen_ex , field_type . flexible_array = parse_length ( tokens , vname , flexible_array ) flexible_array = flexible_array or field_type . flexible_array # anonymous nested union if vname == \";\" and field_type . ref is not None and ( __is_union__ or field_type . ref . __is_union__ ): # add the anonymous struct fields to the parent for nested_field_name , nested_field_type in field_type . ref . __fields_types__ . items (): if nested_field_name in fields_types : raise ParserError ( f \"Duplicate member ` { nested_field_name } `\" ) # set the correct offset nested_field_type = nested_field_type . copy () nested_field_type . base_offset = offset + nested_field_type . base_offset nested_field_type . offset = offset + nested_field_type . offset fields_types [ nested_field_name ] = nested_field_type vname = f \"__anonymous { anonymous } \" anonymous += 1 tokens . push ( \";\" ) fields_types [ vname ] = field_type # calculate the max field size (for the alignment) max_alignment = max ( max_alignment , field_type . alignment ) # align struct if byte order is native if not __is_union__ : # C struct field_type . align_filed_offset () offset = field_type . offset + field_type . vsize t = tokens . pop () if t != \";\" : raise ParserError ( f \"`;` expected but ` { t } ` found\" ) if __is_union__ : # C union # Calculate the sizeof union as size of its largest element size = max ([ x . vsize for x in fields_types . values ()]) else : # C struct # add padding to struct if byte order is native size = offset + calculate_padding ( __byte_order__ , max_alignment , offset ) # Prepare the result result = { \"__fields__\" : list ( fields_types . keys ()), \"__fields_types__\" : fields_types , \"__size__\" : size , \"__is_struct__\" : not __is_union__ , \"__is_union__\" : __is_union__ , \"__is_enum__\" : False , \"__byte_order__\" : __byte_order__ , \"__alignment__\" : max_alignment , \"__name__\" : __name__ , \"__cls__\" : __cls__ , } return result","title":"parse_struct"},{"location":"api/cstruct/","text":"CStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/cstruct.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) pack () Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True","title":"cstruct.cstruct"},{"location":"api/cstruct/#cstruct.cstruct.CStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/cstruct.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"CStruct"},{"location":"api/cstruct/#cstruct.cstruct.CStruct.pack","text":"Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"pack"},{"location":"api/cstruct/#cstruct.cstruct.CStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True","title":"unpack_from"},{"location":"api/field/","text":"FieldType Struct/Union field Attributes: kind ( Kind ) \u2013 struct/union/native c_type ( str ) \u2013 field type ref ( AbstractCStruct ) \u2013 struct/union class ref vlen_ex ( int|callable int ) \u2013 number of elements flexible_array ( bool ) \u2013 True for flexible arrays offset ( int ) \u2013 relative memory position of the field (relative to the struct) padding ( int ) \u2013 padding Source code in cstruct/field.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class FieldType : \"\"\" Struct/Union field Attributes: kind (Kind): struct/union/native c_type (str): field type ref (AbstractCStruct): struct/union class ref vlen_ex (int|callable int): number of elements flexible_array (bool): True for flexible arrays offset (int): relative memory position of the field (relative to the struct) padding (int): padding \"\"\" kind : Kind c_type : str ref : Optional [ Type [ \"AbstractCStruct\" ]] vlen_ex : Union [ int , Callable [[], int ]] flexible_array : bool byte_order : Optional [ str ] offset : int padding : int def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen_ex : Union [ int , Callable [[], int ]], flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen_ex: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen_ex = vlen_ex self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0 def unpack_from ( self , buffer : bytes , offset : int = 0 , context : Optional [ \"AbstractCStruct\" ] = None ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset context: context (cstruct instance) Returns: data: The unpacked data \"\"\" if self . is_native or self . is_enum : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_enum : result = tuple ( map ( self . ref , result )) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen_ex = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : if self . vlen == 0 : # empty array return bytes () else : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data ) @property def vlen ( self ) -> int : \"Number of elements\" try : return self . vlen_ex () if callable ( self . vlen_ex ) else self . vlen_ex except ContextNotFound : return 0 @property def is_array ( self ) -> bool : \"True if field is an array/flexible array\" return self . flexible_array or ( not ( self . vlen == 1 or self . c_type == \"char\" )) @property def is_native ( self ) -> bool : \"True if the field is a native type (e.g. int, char)\" return self . kind == Kind . NATIVE @property def is_enum ( self ) -> bool : \"True if the field is an enum\" return self . kind == Kind . ENUM @property def is_struct ( self ) -> bool : \"True if the field is a struct\" return self . kind == Kind . STRUCT @property def is_union ( self ) -> bool : \"True if the field is an union\" return self . kind == Kind . UNION @property def native_format ( self ) -> str : \"Field format (struct library format)\" if self . is_native : try : return get_native_type ( self . c_type ) . native_format except KeyError : raise ParserError ( f \"Unknown type ` { self . c_type } `\" ) elif self . is_enum : return self . ref . __native_format__ else : return \"c\" @property def fmt ( self ) -> str : \"Field format prefixed by byte order (struct library format)\" if self . is_native or self . is_enum : if self . vlen == 0 : fmt = \"\" else : fmt = ( str ( self . vlen ) if self . vlen > 1 or self . flexible_array else \"\" ) + self . native_format else : # Struct/Union fmt = str ( self . vlen * self . ref . sizeof ()) + self . native_format if self . byte_order : return self . byte_order + fmt else : return fmt @property def vsize ( self ) -> int : \"Field size in bytes\" return struct . calcsize ( self . fmt ) @property def alignment ( self ) -> int : \"Alignment\" if self . is_native or self . is_enum : if self . byte_order is not None : return struct . calcsize ( self . byte_order + self . native_format ) else : return struct . calcsize ( self . native_format ) else : # struct/union return self . ref . __alignment__ def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != \"char\" : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self ) def __repr__ ( self ) -> str : # pragma: no cover return repr ( self . __dict__ ) alignment : int property Alignment fmt : str property Field format prefixed by byte order (struct library format) is_array : bool property True if field is an array/flexible array is_enum : bool property True if the field is an enum is_native : bool property True if the field is a native type (e.g. int, char) is_struct : bool property True if the field is a struct is_union : bool property True if the field is an union native_format : str property Field format (struct library format) vlen : int property Number of elements vsize : int property Field size in bytes __init__ ( kind , c_type , ref , vlen_ex , flexible_array , byte_order , offset ) Initialize a Struct/Union field Parameters: kind ( Kind ) \u2013 struct/union/native c_type ( str ) \u2013 field type ref ( Optional [ Type [ AbstractCStruct ]] ) \u2013 struct/union class ref vlen_ex ( Union [ int , Callable [[], int ]] ) \u2013 number of elements flexible_array ( bool ) \u2013 True for flexible arrays offset ( int ) \u2013 relative memory position of the field (relative to the struct) Source code in cstruct/field.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen_ex : Union [ int , Callable [[], int ]], flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen_ex: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen_ex = vlen_ex self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0 align_filed_offset () If the byte order is native, align the field Source code in cstruct/field.py 268 269 270 271 272 def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != \"char\" : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding copy () Return a shallow copy of this FieldType Source code in cstruct/field.py 274 275 276 def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self ) pack ( data ) Pack the field into bytes Parameters: data ( Any ) \u2013 data to be packed Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/field.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen_ex = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : if self . vlen == 0 : # empty array return bytes () else : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data ) unpack_from ( buffer , offset = 0 , context = None ) Unpack bytes containing packed C structure data Parameters: buffer ( bytes ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset context ( Optional [ AbstractCStruct ] , default: None ) \u2013 context (cstruct instance) Returns: data ( Any ) \u2013 The unpacked data Source code in cstruct/field.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def unpack_from ( self , buffer : bytes , offset : int = 0 , context : Optional [ \"AbstractCStruct\" ] = None ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset context: context (cstruct instance) Returns: data: The unpacked data \"\"\" if self . is_native or self . is_enum : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_enum : result = tuple ( map ( self . ref , result )) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances Kind Bases: Enum Field type Source code in cstruct/field.py 67 68 69 70 71 72 73 74 75 76 77 78 79 class Kind ( Enum ): \"\"\" Field type \"\"\" NATIVE = 0 \"Native type (e.g. int, char)\" STRUCT = 1 \"Struct type\" UNION = 2 \"Union type\" ENUM = 3 \"Enum type\" ENUM = 3 class-attribute instance-attribute Enum type NATIVE = 0 class-attribute instance-attribute Native type (e.g. int, char) STRUCT = 1 class-attribute instance-attribute Struct type UNION = 2 class-attribute instance-attribute Union type get_cstruct_context () Get the current CStruct context (instance) from the stack Source code in cstruct/field.py 53 54 55 56 57 58 59 60 61 62 63 64 def get_cstruct_context () -> Optional [ \"AbstractCStruct\" ]: \"\"\" Get the current CStruct context (instance) from the stack \"\"\" from .abstract import AbstractCStruct stack = inspect . stack () for frame in stack : caller_self = frame . frame . f_locals . get ( \"self\" ) if isinstance ( caller_self , AbstractCStruct ): return caller_self return None","title":"cstruct.field"},{"location":"api/field/#cstruct.field.FieldType","text":"Struct/Union field Attributes: kind ( Kind ) \u2013 struct/union/native c_type ( str ) \u2013 field type ref ( AbstractCStruct ) \u2013 struct/union class ref vlen_ex ( int|callable int ) \u2013 number of elements flexible_array ( bool ) \u2013 True for flexible arrays offset ( int ) \u2013 relative memory position of the field (relative to the struct) padding ( int ) \u2013 padding Source code in cstruct/field.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class FieldType : \"\"\" Struct/Union field Attributes: kind (Kind): struct/union/native c_type (str): field type ref (AbstractCStruct): struct/union class ref vlen_ex (int|callable int): number of elements flexible_array (bool): True for flexible arrays offset (int): relative memory position of the field (relative to the struct) padding (int): padding \"\"\" kind : Kind c_type : str ref : Optional [ Type [ \"AbstractCStruct\" ]] vlen_ex : Union [ int , Callable [[], int ]] flexible_array : bool byte_order : Optional [ str ] offset : int padding : int def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen_ex : Union [ int , Callable [[], int ]], flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen_ex: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen_ex = vlen_ex self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0 def unpack_from ( self , buffer : bytes , offset : int = 0 , context : Optional [ \"AbstractCStruct\" ] = None ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset context: context (cstruct instance) Returns: data: The unpacked data \"\"\" if self . is_native or self . is_enum : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_enum : result = tuple ( map ( self . ref , result )) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen_ex = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : if self . vlen == 0 : # empty array return bytes () else : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data ) @property def vlen ( self ) -> int : \"Number of elements\" try : return self . vlen_ex () if callable ( self . vlen_ex ) else self . vlen_ex except ContextNotFound : return 0 @property def is_array ( self ) -> bool : \"True if field is an array/flexible array\" return self . flexible_array or ( not ( self . vlen == 1 or self . c_type == \"char\" )) @property def is_native ( self ) -> bool : \"True if the field is a native type (e.g. int, char)\" return self . kind == Kind . NATIVE @property def is_enum ( self ) -> bool : \"True if the field is an enum\" return self . kind == Kind . ENUM @property def is_struct ( self ) -> bool : \"True if the field is a struct\" return self . kind == Kind . STRUCT @property def is_union ( self ) -> bool : \"True if the field is an union\" return self . kind == Kind . UNION @property def native_format ( self ) -> str : \"Field format (struct library format)\" if self . is_native : try : return get_native_type ( self . c_type ) . native_format except KeyError : raise ParserError ( f \"Unknown type ` { self . c_type } `\" ) elif self . is_enum : return self . ref . __native_format__ else : return \"c\" @property def fmt ( self ) -> str : \"Field format prefixed by byte order (struct library format)\" if self . is_native or self . is_enum : if self . vlen == 0 : fmt = \"\" else : fmt = ( str ( self . vlen ) if self . vlen > 1 or self . flexible_array else \"\" ) + self . native_format else : # Struct/Union fmt = str ( self . vlen * self . ref . sizeof ()) + self . native_format if self . byte_order : return self . byte_order + fmt else : return fmt @property def vsize ( self ) -> int : \"Field size in bytes\" return struct . calcsize ( self . fmt ) @property def alignment ( self ) -> int : \"Alignment\" if self . is_native or self . is_enum : if self . byte_order is not None : return struct . calcsize ( self . byte_order + self . native_format ) else : return struct . calcsize ( self . native_format ) else : # struct/union return self . ref . __alignment__ def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != \"char\" : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self ) def __repr__ ( self ) -> str : # pragma: no cover return repr ( self . __dict__ )","title":"FieldType"},{"location":"api/field/#cstruct.field.FieldType.alignment","text":"Alignment","title":"alignment"},{"location":"api/field/#cstruct.field.FieldType.fmt","text":"Field format prefixed by byte order (struct library format)","title":"fmt"},{"location":"api/field/#cstruct.field.FieldType.is_array","text":"True if field is an array/flexible array","title":"is_array"},{"location":"api/field/#cstruct.field.FieldType.is_enum","text":"True if the field is an enum","title":"is_enum"},{"location":"api/field/#cstruct.field.FieldType.is_native","text":"True if the field is a native type (e.g. int, char)","title":"is_native"},{"location":"api/field/#cstruct.field.FieldType.is_struct","text":"True if the field is a struct","title":"is_struct"},{"location":"api/field/#cstruct.field.FieldType.is_union","text":"True if the field is an union","title":"is_union"},{"location":"api/field/#cstruct.field.FieldType.native_format","text":"Field format (struct library format)","title":"native_format"},{"location":"api/field/#cstruct.field.FieldType.vlen","text":"Number of elements","title":"vlen"},{"location":"api/field/#cstruct.field.FieldType.vsize","text":"Field size in bytes","title":"vsize"},{"location":"api/field/#cstruct.field.FieldType.__init__","text":"Initialize a Struct/Union field Parameters: kind ( Kind ) \u2013 struct/union/native c_type ( str ) \u2013 field type ref ( Optional [ Type [ AbstractCStruct ]] ) \u2013 struct/union class ref vlen_ex ( Union [ int , Callable [[], int ]] ) \u2013 number of elements flexible_array ( bool ) \u2013 True for flexible arrays offset ( int ) \u2013 relative memory position of the field (relative to the struct) Source code in cstruct/field.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen_ex : Union [ int , Callable [[], int ]], flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen_ex: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen_ex = vlen_ex self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0","title":"__init__"},{"location":"api/field/#cstruct.field.FieldType.align_filed_offset","text":"If the byte order is native, align the field Source code in cstruct/field.py 268 269 270 271 272 def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != \"char\" : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding","title":"align_filed_offset"},{"location":"api/field/#cstruct.field.FieldType.copy","text":"Return a shallow copy of this FieldType Source code in cstruct/field.py 274 275 276 def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self )","title":"copy"},{"location":"api/field/#cstruct.field.FieldType.pack","text":"Pack the field into bytes Parameters: data ( Any ) \u2013 data to be packed Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/field.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen_ex = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : if self . vlen == 0 : # empty array return bytes () else : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data )","title":"pack"},{"location":"api/field/#cstruct.field.FieldType.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: buffer ( bytes ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset context ( Optional [ AbstractCStruct ] , default: None ) \u2013 context (cstruct instance) Returns: data ( Any ) \u2013 The unpacked data Source code in cstruct/field.py 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def unpack_from ( self , buffer : bytes , offset : int = 0 , context : Optional [ \"AbstractCStruct\" ] = None ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset context: context (cstruct instance) Returns: data: The unpacked data \"\"\" if self . is_native or self . is_enum : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_enum : result = tuple ( map ( self . ref , result )) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances","title":"unpack_from"},{"location":"api/field/#cstruct.field.Kind","text":"Bases: Enum Field type Source code in cstruct/field.py 67 68 69 70 71 72 73 74 75 76 77 78 79 class Kind ( Enum ): \"\"\" Field type \"\"\" NATIVE = 0 \"Native type (e.g. int, char)\" STRUCT = 1 \"Struct type\" UNION = 2 \"Union type\" ENUM = 3 \"Enum type\"","title":"Kind"},{"location":"api/field/#cstruct.field.Kind.ENUM","text":"Enum type","title":"ENUM"},{"location":"api/field/#cstruct.field.Kind.NATIVE","text":"Native type (e.g. int, char)","title":"NATIVE"},{"location":"api/field/#cstruct.field.Kind.STRUCT","text":"Struct type","title":"STRUCT"},{"location":"api/field/#cstruct.field.Kind.UNION","text":"Union type","title":"UNION"},{"location":"api/field/#cstruct.field.get_cstruct_context","text":"Get the current CStruct context (instance) from the stack Source code in cstruct/field.py 53 54 55 56 57 58 59 60 61 62 63 64 def get_cstruct_context () -> Optional [ \"AbstractCStruct\" ]: \"\"\" Get the current CStruct context (instance) from the stack \"\"\" from .abstract import AbstractCStruct stack = inspect . stack () for frame in stack : caller_self = frame . frame . f_locals . get ( \"self\" ) if isinstance ( caller_self , AbstractCStruct ): return caller_self return None","title":"get_cstruct_context"},{"location":"api/mem_cstruct/","text":"MemCStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __mem__ \u2013 mutable character buffer __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None __base__ = 0 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ] def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen_ex = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size ) memcpy ( destination , source , num ) Copies the values of num bytes from source to the struct memory Parameters: destination ( int ) \u2013 destination address source ( bytes ) \u2013 source data to be copied num ( int ) \u2013 number of bytes to copy Source code in cstruct/mem_cstruct.py 88 89 90 91 92 93 94 95 96 97 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) pack () Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/mem_cstruct.py 99 100 101 102 103 104 105 106 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ] set_flexible_array_length ( flexible_array_length ) Set flexible array length (i.e. number of elements) Parameters: flexible_array_length ( Optional [ int ] ) \u2013 flexible array length Source code in cstruct/mem_cstruct.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/mem_cstruct.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True","title":"cstruct.mem_cstruct"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __mem__ \u2013 mutable character buffer __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None __base__ = 0 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ] def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen_ex = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size )","title":"MemCStruct"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.memcpy","text":"Copies the values of num bytes from source to the struct memory Parameters: destination ( int ) \u2013 destination address source ( bytes ) \u2013 source data to be copied num ( int ) \u2013 number of bytes to copy Source code in cstruct/mem_cstruct.py 88 89 90 91 92 93 94 95 96 97 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num )","title":"memcpy"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.pack","text":"Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/mem_cstruct.py 99 100 101 102 103 104 105 106 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ]","title":"pack"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.set_flexible_array_length","text":"Set flexible array length (i.e. number of elements) Parameters: flexible_array_length ( Optional [ int ] ) \u2013 flexible array length Source code in cstruct/mem_cstruct.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass","title":"set_flexible_array_length"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/mem_cstruct.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True","title":"unpack_from"},{"location":"api/module/","text":"BIG_ENDIAN = '>' module-attribute Big-endian, std. size & alignment LITTLE_ENDIAN = '<' module-attribute Little-endian, std. size & alignment NATIVE_ORDER = '@' module-attribute Native order, size & alignment CEnum Bases: AbstractCEnum Source code in cstruct/cenum.py 4 5 6 7 8 class CEnum ( AbstractCEnum ): @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ sizeof () classmethod Type size (in bytes) Source code in cstruct/cenum.py 5 6 7 8 @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ CStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/cstruct.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) pack () Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True MemCStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __mem__ \u2013 mutable character buffer __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None __base__ = 0 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ] def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen_ex = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size ) memcpy ( destination , source , num ) Copies the values of num bytes from source to the struct memory Parameters: destination ( int ) \u2013 destination address source ( bytes ) \u2013 source data to be copied num ( int ) \u2013 number of bytes to copy Source code in cstruct/mem_cstruct.py 88 89 90 91 92 93 94 95 96 97 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) pack () Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/mem_cstruct.py 99 100 101 102 103 104 105 106 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ] set_flexible_array_length ( flexible_array_length ) Set flexible array length (i.e. number of elements) Parameters: flexible_array_length ( Optional [ int ] ) \u2013 flexible array length Source code in cstruct/mem_cstruct.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/mem_cstruct.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True define ( key , value ) Define a constant that can be used in the C struct Examples: >>> define ( \"INIT_THREAD_SIZE\" , 16384 ) Parameters: key ( str ) \u2013 identifier value ( Any ) \u2013 value of the constant Source code in cstruct/__init__.py 67 68 69 70 71 72 73 74 75 76 77 78 def define ( key : str , value : Any ) -> None : \"\"\" Define a constant that can be used in the C struct Examples: >>> define(\"INIT_THREAD_SIZE\", 16384) Args: key: identifier value: value of the constant \"\"\" DEFINES [ key ] = value get_type ( type_ ) Get a data type (struct, union, enum) by name Examples: >>> get_type ( \"struct Position\" ) <class 'abc.Position'> >>> get_type ( \"enum htmlfont\" ) <enum 'htmlfont'> Parameters: type_ ( str ) \u2013 C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: class ( Any ) \u2013 data type class Raises: KeyError \u2013 If type is not defined Source code in cstruct/__init__.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def get_type ( type_ : str ) -> Any : \"\"\" Get a data type (struct, union, enum) by name Examples: >>> get_type(\"struct Position\") <class 'abc.Position'> >>> get_type(\"enum htmlfont\") <enum 'htmlfont'> Args: type_: C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: class: data type class Raises: KeyError: If type is not defined \"\"\" while type_ in TYPEDEFS : type_ = TYPEDEFS [ type_ ] if isinstance ( type_ , CStructMeta ): return type_ elif type_ . startswith ( \"struct \" ) or type_ . startswith ( \"union \" ): kind , type_ = type_ . split ( \" \" , 1 ) try : return STRUCTS [ type_ ] except KeyError : raise KeyError ( f \"Unknown { kind } ` { type_ } `\" ) elif type_ . startswith ( \"enum \" ): kind , type_ = type_ . split ( \" \" , 1 ) try : return ENUMS [ type_ ] except KeyError : raise KeyError ( f \"Unknown { kind } ` { type_ } `\" ) else : return get_native_type ( type_ ) getdef ( key ) Return the value for a constant Examples: >>> define ( \"INIT_THREAD_SIZE\" , 16384 ) >>> getdef ( \"INIT_THREAD_SIZE\" ) Parameters: key ( str ) \u2013 identifier Raises: KeyError \u2013 If key is not defined Source code in cstruct/__init__.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def getdef ( key : str ) -> Any : \"\"\" Return the value for a constant Examples: >>> define(\"INIT_THREAD_SIZE\", 16384) >>> getdef(\"INIT_THREAD_SIZE\") Args: key: identifier Raises: KeyError: If key is not defined \"\"\" return DEFINES [ key ] parse ( __struct__ , __cls__ = None , ** kargs ) Return a new class mapping a C struct/union/enum definition. If the string does not contains any definition, return None. If the string contains multiple struct/union/enum definitions, returns the last definition. Examples: >>> cstruct . parse ( 'struct Pair { unsigned char a; unsigned char b; };' ) <class 'abc.Pair'> Parameters: __struct__ ( str ) \u2013 definition of the struct (or union/enum) in C syntax __cls__ ( type , default: None ) \u2013 super class - CStruct(default) or MemCStruct __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER Returns: cls ( Union [ Type [ AbstractCStruct ], Type [ AbstractCEnum ], None] ) \u2013 cls subclass Raises: ParserError \u2013 Parsing exception Source code in cstruct/__init__.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def parse ( __struct__ : str , __cls__ : Optional [ Type [ AbstractCStruct ]] = None , ** kargs : Dict [ str , Any ] ) -> Union [ Type [ AbstractCStruct ], Type [ AbstractCEnum ], None ]: \"\"\" Return a new class mapping a C struct/union/enum definition. If the string does not contains any definition, return None. If the string contains multiple struct/union/enum definitions, returns the last definition. Examples: >>> cstruct.parse('struct Pair { unsigned char a; unsigned char b; };') <class 'abc.Pair'> Args: __struct__ (str): definition of the struct (or union/enum) in C syntax __cls__ (type): super class - CStruct(default) or MemCStruct __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER Returns: cls: __cls__ subclass Raises: cstruct.exceptions.ParserError: Parsing exception \"\"\" if __cls__ is None : __cls__ = MemCStruct cls_def = parse_struct_def ( __struct__ , __cls__ = __cls__ , process_muliple_definition = True , ** kargs ) if cls_def is None : return None return cls_def [ \"__cls__\" ] . parse ( cls_def , ** kargs ) sizeof ( type_ ) Return the size of the type. Examples: >>> sizeof ( \"struct Position\" ) 16 >>> sizeof ( 'enum htmlfont' ) 4 >>> sizeof ( \"int\" ) 4 Parameters: type_ ( str ) \u2013 C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: size ( int ) \u2013 size in bytes Raises: KeyError \u2013 If type is not defined Source code in cstruct/__init__.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def sizeof ( type_ : str ) -> int : \"\"\" Return the size of the type. Examples: >>> sizeof(\"struct Position\") 16 >>> sizeof('enum htmlfont') 4 >>> sizeof(\"int\") 4 Args: type_: C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: size: size in bytes Raises: KeyError: If type is not defined \"\"\" while type_ in TYPEDEFS : type_ = TYPEDEFS [ type_ ] data_type = get_type ( type_ ) return data_type . sizeof () typedef ( type_ , alias ) Define an alias name for a data type Examples: >>> typedef ( \"int\" , \"status\" ) >>> sizeof ( \"status\" ) 4 Parameters: type_ ( str ) \u2013 data type alias ( str ) \u2013 new alias name Source code in cstruct/__init__.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def typedef ( type_ : str , alias : str ) -> None : \"\"\" Define an alias name for a data type Examples: >>> typedef(\"int\", \"status\") >>> sizeof(\"status\") 4 Args: type_: data type alias: new alias name \"\"\" TYPEDEFS [ alias ] = type_ undef ( key ) Undefine a symbol that was previously defined with define Examples: >>> define ( \"INIT_THREAD_SIZE\" , 16384 ) >>> undef ( \"INIT_THREAD_SIZE\" ) Parameters: key ( str ) \u2013 identifier Raises: KeyError \u2013 If key is not defined Source code in cstruct/__init__.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def undef ( key : str ) -> None : \"\"\" Undefine a symbol that was previously defined with define Examples: >>> define(\"INIT_THREAD_SIZE\", 16384) >>> undef(\"INIT_THREAD_SIZE\") Args: key: identifier Raises: KeyError: If key is not defined \"\"\" del DEFINES [ key ]","title":"cstruct"},{"location":"api/module/#cstruct.BIG_ENDIAN","text":"Big-endian, std. size & alignment","title":"BIG_ENDIAN"},{"location":"api/module/#cstruct.LITTLE_ENDIAN","text":"Little-endian, std. size & alignment","title":"LITTLE_ENDIAN"},{"location":"api/module/#cstruct.NATIVE_ORDER","text":"Native order, size & alignment","title":"NATIVE_ORDER"},{"location":"api/module/#cstruct.CEnum","text":"Bases: AbstractCEnum Source code in cstruct/cenum.py 4 5 6 7 8 class CEnum ( AbstractCEnum ): @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__","title":"CEnum"},{"location":"api/module/#cstruct.CEnum.sizeof","text":"Type size (in bytes) Source code in cstruct/cenum.py 5 6 7 8 @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__","title":"sizeof"},{"location":"api/module/#cstruct.CStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/cstruct.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"CStruct"},{"location":"api/module/#cstruct.CStruct.pack","text":"Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"pack"},{"location":"api/module/#cstruct.CStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True","title":"unpack_from"},{"location":"api/module/#cstruct.MemCStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: __struct__ ( str ) \u2013 definition of the struct (or union) in C syntax __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ ( bool ) \u2013 True for union definitions, False for struct definitions __mem__ \u2013 mutable character buffer __size__ ( int ) \u2013 size of the structure in bytes (flexible array member size is omitted) __fields__ ( list ) \u2013 list of structure fields __fields_types__ ( dict ) \u2013 dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None __base__ = 0 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ] def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen_ex = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size )","title":"MemCStruct"},{"location":"api/module/#cstruct.MemCStruct.memcpy","text":"Copies the values of num bytes from source to the struct memory Parameters: destination ( int ) \u2013 destination address source ( bytes ) \u2013 source data to be copied num ( int ) \u2013 number of bytes to copy Source code in cstruct/mem_cstruct.py 88 89 90 91 92 93 94 95 96 97 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num )","title":"memcpy"},{"location":"api/module/#cstruct.MemCStruct.pack","text":"Pack the structure data into bytes Returns: bytes ( bytes ) \u2013 The packed structure Source code in cstruct/mem_cstruct.py 99 100 101 102 103 104 105 106 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [ self . __base__ : self . __base__ + self . size ]","title":"pack"},{"location":"api/module/#cstruct.MemCStruct.set_flexible_array_length","text":"Set flexible array length (i.e. number of elements) Parameters: flexible_array_length ( Optional [ int ] ) \u2013 flexible array length Source code in cstruct/mem_cstruct.py 108 109 110 111 112 113 114 115 116 117 118 119 120 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass","title":"set_flexible_array_length"},{"location":"api/module/#cstruct.MemCStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: buffer ( Optional [ bytes ] ) \u2013 bytes to be unpacked offset ( int , default: 0 ) \u2013 optional buffer offset flexible_array_length ( Optional [ int ] , default: None ) \u2013 optional flexible array length (number of elements) Source code in cstruct/mem_cstruct.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array length (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer elif isinstance ( buffer , int ): # buffer is a pointer self . __mem__ = ctypes . cast ( buffer , ctypes . POINTER ( ctypes . c_char * self . size )) . contents else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True","title":"unpack_from"},{"location":"api/module/#cstruct.define","text":"Define a constant that can be used in the C struct Examples: >>> define ( \"INIT_THREAD_SIZE\" , 16384 ) Parameters: key ( str ) \u2013 identifier value ( Any ) \u2013 value of the constant Source code in cstruct/__init__.py 67 68 69 70 71 72 73 74 75 76 77 78 def define ( key : str , value : Any ) -> None : \"\"\" Define a constant that can be used in the C struct Examples: >>> define(\"INIT_THREAD_SIZE\", 16384) Args: key: identifier value: value of the constant \"\"\" DEFINES [ key ] = value","title":"define"},{"location":"api/module/#cstruct.get_type","text":"Get a data type (struct, union, enum) by name Examples: >>> get_type ( \"struct Position\" ) <class 'abc.Position'> >>> get_type ( \"enum htmlfont\" ) <enum 'htmlfont'> Parameters: type_ ( str ) \u2013 C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: class ( Any ) \u2013 data type class Raises: KeyError \u2013 If type is not defined Source code in cstruct/__init__.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def get_type ( type_ : str ) -> Any : \"\"\" Get a data type (struct, union, enum) by name Examples: >>> get_type(\"struct Position\") <class 'abc.Position'> >>> get_type(\"enum htmlfont\") <enum 'htmlfont'> Args: type_: C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: class: data type class Raises: KeyError: If type is not defined \"\"\" while type_ in TYPEDEFS : type_ = TYPEDEFS [ type_ ] if isinstance ( type_ , CStructMeta ): return type_ elif type_ . startswith ( \"struct \" ) or type_ . startswith ( \"union \" ): kind , type_ = type_ . split ( \" \" , 1 ) try : return STRUCTS [ type_ ] except KeyError : raise KeyError ( f \"Unknown { kind } ` { type_ } `\" ) elif type_ . startswith ( \"enum \" ): kind , type_ = type_ . split ( \" \" , 1 ) try : return ENUMS [ type_ ] except KeyError : raise KeyError ( f \"Unknown { kind } ` { type_ } `\" ) else : return get_native_type ( type_ )","title":"get_type"},{"location":"api/module/#cstruct.getdef","text":"Return the value for a constant Examples: >>> define ( \"INIT_THREAD_SIZE\" , 16384 ) >>> getdef ( \"INIT_THREAD_SIZE\" ) Parameters: key ( str ) \u2013 identifier Raises: KeyError \u2013 If key is not defined Source code in cstruct/__init__.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def getdef ( key : str ) -> Any : \"\"\" Return the value for a constant Examples: >>> define(\"INIT_THREAD_SIZE\", 16384) >>> getdef(\"INIT_THREAD_SIZE\") Args: key: identifier Raises: KeyError: If key is not defined \"\"\" return DEFINES [ key ]","title":"getdef"},{"location":"api/module/#cstruct.parse","text":"Return a new class mapping a C struct/union/enum definition. If the string does not contains any definition, return None. If the string contains multiple struct/union/enum definitions, returns the last definition. Examples: >>> cstruct . parse ( 'struct Pair { unsigned char a; unsigned char b; };' ) <class 'abc.Pair'> Parameters: __struct__ ( str ) \u2013 definition of the struct (or union/enum) in C syntax __cls__ ( type , default: None ) \u2013 super class - CStruct(default) or MemCStruct __byte_order__ ( str ) \u2013 byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER Returns: cls ( Union [ Type [ AbstractCStruct ], Type [ AbstractCEnum ], None] ) \u2013 cls subclass Raises: ParserError \u2013 Parsing exception Source code in cstruct/__init__.py 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 def parse ( __struct__ : str , __cls__ : Optional [ Type [ AbstractCStruct ]] = None , ** kargs : Dict [ str , Any ] ) -> Union [ Type [ AbstractCStruct ], Type [ AbstractCEnum ], None ]: \"\"\" Return a new class mapping a C struct/union/enum definition. If the string does not contains any definition, return None. If the string contains multiple struct/union/enum definitions, returns the last definition. Examples: >>> cstruct.parse('struct Pair { unsigned char a; unsigned char b; };') <class 'abc.Pair'> Args: __struct__ (str): definition of the struct (or union/enum) in C syntax __cls__ (type): super class - CStruct(default) or MemCStruct __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER Returns: cls: __cls__ subclass Raises: cstruct.exceptions.ParserError: Parsing exception \"\"\" if __cls__ is None : __cls__ = MemCStruct cls_def = parse_struct_def ( __struct__ , __cls__ = __cls__ , process_muliple_definition = True , ** kargs ) if cls_def is None : return None return cls_def [ \"__cls__\" ] . parse ( cls_def , ** kargs )","title":"parse"},{"location":"api/module/#cstruct.sizeof","text":"Return the size of the type. Examples: >>> sizeof ( \"struct Position\" ) 16 >>> sizeof ( 'enum htmlfont' ) 4 >>> sizeof ( \"int\" ) 4 Parameters: type_ ( str ) \u2013 C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: size ( int ) \u2013 size in bytes Raises: KeyError \u2013 If type is not defined Source code in cstruct/__init__.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def sizeof ( type_ : str ) -> int : \"\"\" Return the size of the type. Examples: >>> sizeof(\"struct Position\") 16 >>> sizeof('enum htmlfont') 4 >>> sizeof(\"int\") 4 Args: type_: C type, struct or union (e.g. 'short int' or 'struct ZYZ'), enum or native type Returns: size: size in bytes Raises: KeyError: If type is not defined \"\"\" while type_ in TYPEDEFS : type_ = TYPEDEFS [ type_ ] data_type = get_type ( type_ ) return data_type . sizeof ()","title":"sizeof"},{"location":"api/module/#cstruct.typedef","text":"Define an alias name for a data type Examples: >>> typedef ( \"int\" , \"status\" ) >>> sizeof ( \"status\" ) 4 Parameters: type_ ( str ) \u2013 data type alias ( str ) \u2013 new alias name Source code in cstruct/__init__.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def typedef ( type_ : str , alias : str ) -> None : \"\"\" Define an alias name for a data type Examples: >>> typedef(\"int\", \"status\") >>> sizeof(\"status\") 4 Args: type_: data type alias: new alias name \"\"\" TYPEDEFS [ alias ] = type_","title":"typedef"},{"location":"api/module/#cstruct.undef","text":"Undefine a symbol that was previously defined with define Examples: >>> define ( \"INIT_THREAD_SIZE\" , 16384 ) >>> undef ( \"INIT_THREAD_SIZE\" ) Parameters: key ( str ) \u2013 identifier Raises: KeyError \u2013 If key is not defined Source code in cstruct/__init__.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 def undef ( key : str ) -> None : \"\"\" Undefine a symbol that was previously defined with define Examples: >>> define(\"INIT_THREAD_SIZE\", 16384) >>> undef(\"INIT_THREAD_SIZE\") Args: key: identifier Raises: KeyError: If key is not defined \"\"\" del DEFINES [ key ]","title":"undef"},{"location":"api/native_types/","text":"AbstractNativeType Source code in cstruct/native_types.py 106 107 108 109 110 111 112 113 114 115 116 117 118 class AbstractNativeType ( metaclass = NativeTypeMeta ): type_name : str = \"\" \" Type name \" native_format : str = \"\" \" Type format \" def __str__ ( self ) -> str : return self . type_name @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ native_format : str = '' class-attribute instance-attribute Type format type_name : str = '' class-attribute instance-attribute Type name sizeof () classmethod Type size (in bytes) Source code in cstruct/native_types.py 115 116 117 118 @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ NativeTypeMeta Bases: ABCMeta Source code in cstruct/native_types.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class NativeTypeMeta ( ABCMeta ): __size__ : int = 0 \" Size in bytes \" def __new__ ( metacls : Type [ type ], name : str , bases : Tuple [ str ], namespace : Dict [ str , Any ]) -> Type [ Any ]: if namespace . get ( \"native_format\" ): native_format = namespace [ \"native_format\" ] namespace [ \"__size__\" ] = struct . calcsize ( native_format ) else : native_format = None namespace [ \"native_format\" ] = None namespace [ \"__size__\" ] = None new_class : Type [ AbstractNativeType ] = super () . __new__ ( metacls , name , bases , namespace ) # type: ignore if namespace . get ( \"type_name\" ): NATIVE_TYPES [ namespace [ \"type_name\" ]] = new_class return new_class def __len__ ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ @property def size ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ __size__ : int = 0 class-attribute instance-attribute Size in bytes size : int property Type size (in bytes) __len__ () Type size (in bytes) Source code in cstruct/native_types.py 96 97 98 def __len__ ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ get_native_type ( type_ ) Get a base data type by name Parameters: type_ ( str ) \u2013 data type Returns: class ( Type [ AbstractNativeType ] ) \u2013 data type class Raises: KeyError \u2013 If type is not defined Source code in cstruct/native_types.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_native_type ( type_ : str ) -> Type [ \"AbstractNativeType\" ]: \"\"\" Get a base data type by name Args: type_: data type Returns: class: data type class Raises: KeyError: If type is not defined \"\"\" try : return NATIVE_TYPES [ type_ ] except KeyError : raise KeyError ( f \"Unknown type ` { type_ } `\" )","title":"cstruct.native_types"},{"location":"api/native_types/#cstruct.native_types.AbstractNativeType","text":"Source code in cstruct/native_types.py 106 107 108 109 110 111 112 113 114 115 116 117 118 class AbstractNativeType ( metaclass = NativeTypeMeta ): type_name : str = \"\" \" Type name \" native_format : str = \"\" \" Type format \" def __str__ ( self ) -> str : return self . type_name @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__","title":"AbstractNativeType"},{"location":"api/native_types/#cstruct.native_types.AbstractNativeType.native_format","text":"Type format","title":"native_format"},{"location":"api/native_types/#cstruct.native_types.AbstractNativeType.type_name","text":"Type name","title":"type_name"},{"location":"api/native_types/#cstruct.native_types.AbstractNativeType.sizeof","text":"Type size (in bytes) Source code in cstruct/native_types.py 115 116 117 118 @classmethod def sizeof ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__","title":"sizeof"},{"location":"api/native_types/#cstruct.native_types.NativeTypeMeta","text":"Bases: ABCMeta Source code in cstruct/native_types.py 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 class NativeTypeMeta ( ABCMeta ): __size__ : int = 0 \" Size in bytes \" def __new__ ( metacls : Type [ type ], name : str , bases : Tuple [ str ], namespace : Dict [ str , Any ]) -> Type [ Any ]: if namespace . get ( \"native_format\" ): native_format = namespace [ \"native_format\" ] namespace [ \"__size__\" ] = struct . calcsize ( native_format ) else : native_format = None namespace [ \"native_format\" ] = None namespace [ \"__size__\" ] = None new_class : Type [ AbstractNativeType ] = super () . __new__ ( metacls , name , bases , namespace ) # type: ignore if namespace . get ( \"type_name\" ): NATIVE_TYPES [ namespace [ \"type_name\" ]] = new_class return new_class def __len__ ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__ @property def size ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__","title":"NativeTypeMeta"},{"location":"api/native_types/#cstruct.native_types.NativeTypeMeta.__size__","text":"Size in bytes","title":"__size__"},{"location":"api/native_types/#cstruct.native_types.NativeTypeMeta.size","text":"Type size (in bytes)","title":"size"},{"location":"api/native_types/#cstruct.native_types.NativeTypeMeta.__len__","text":"Type size (in bytes) Source code in cstruct/native_types.py 96 97 98 def __len__ ( cls ) -> int : \"Type size (in bytes)\" return cls . __size__","title":"__len__"},{"location":"api/native_types/#cstruct.native_types.get_native_type","text":"Get a base data type by name Parameters: type_ ( str ) \u2013 data type Returns: class ( Type [ AbstractNativeType ] ) \u2013 data type class Raises: KeyError \u2013 If type is not defined Source code in cstruct/native_types.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def get_native_type ( type_ : str ) -> Type [ \"AbstractNativeType\" ]: \"\"\" Get a base data type by name Args: type_: data type Returns: class: data type class Raises: KeyError: If type is not defined \"\"\" try : return NATIVE_TYPES [ type_ ] except KeyError : raise KeyError ( f \"Unknown type ` { type_ } `\" )","title":"get_native_type"},{"location":"examples/dir/","text":"The following program prints the names of the files in a directory, calling the libc functions getcwd , opendir , readdir , and closedir : #!/usr/bin/env python import ctypes import sys import cstruct libc = ctypes.cdll.LoadLibrary(\"libc.so.6\") # opendir libc.opendir.argtypes = [ctypes.c_char_p] libc.opendir.restype = ctypes.c_void_p # readdir libc.readdir.argtypes = [ctypes.c_void_p] libc.readdir.restype = ctypes.c_void_p # closedir libc.closedir.argtypes = [ctypes.c_void_p] libc.closedir.restype = ctypes.c_int class DType(cstruct.CEnum): __size__ = 1 __def__ = \"\"\" enum d_type { DT_UNKNOWN = 0x0, DT_FIFO = 0x1, DT_CHR = 0x2, DT_DIR = 0x4, DT_BLK = 0x6, DT_REG = 0x8, DT_LNK = 0xa, DT_SOCK = 0xc }; \"\"\" def __str__(self): return { DType.DT_UNKNOWN: \"<unknown>\", DType.DT_FIFO: \"<fifo>\", DType.DT_CHR: \"<char>\", DType.DT_DIR: \"<dir>\", DType.DT_BLK: \"<block>\", DType.DT_REG: \"<regular>\", DType.DT_LNK: \"<link>\", DType.DT_SOCK: \"<socket>\", }[self] class Dirent(cstruct.MemCStruct): __def__ = \"\"\" #define PATH_MAX 4096 typedef long ino_t; typedef long off_t; struct dirent { ino_t d_ino; /* Inode number */ off_t d_off; /* Not an offset */ unsigned short d_reclen; /* Length of this record */ unsigned char d_type; /* Type of file; not supported by all filesystem types */ char d_name[256]; /* Null-terminated filename */ }; \"\"\" @property def name(self): return ctypes.c_char_p(self.d_name).value.decode(\"ascii\") @property def type(self): return DType(self.d_type) def main(): if len(sys.argv) > 1: cwd = ctypes.create_string_buffer(sys.argv[1].encode(\"ascii\")) else: # Get current dir cwd = ctypes.create_string_buffer(cstruct.getdef(\"PATH_MAX\") + 1) assert libc.getcwd(cwd, ctypes.sizeof(cwd)) != 0 # Open dir dp = libc.opendir(cwd) assert dp != 0 # Read dir entries ep = libc.readdir(dp) while ep: contents = ctypes.cast(ep, ctypes.POINTER(ctypes.c_char * Dirent.size)).contents dirent = Dirent(contents) print(f\"{dirent.d_ino:8} {dirent.type:10} {dirent.name}\") ep = libc.readdir(dp) # Close dir libc.closedir(dp) if __name__ == \"__main__\": main()","title":"dir.py"},{"location":"examples/fdisk/","text":"The following program reads the DOS-type (MBR) partition table from a disk. #!/usr/bin/env python import argparse import sys from pathlib import Path import cstruct UNITS = ['B', 'K', 'M', 'G', 'T'] SECTOR_SIZE = 512 TYPES = { 0x00: \"Empty\", 0x01: \"FAT12\", 0x05: \"Extended\", 0x06: \"FAT16\", 0x07: \"HPFS/NTFS/exFAT\", 0x0B: \"W95 FAT32\", 0x0C: \"W95 FAT32 (LBA)\", 0x0E: \"W95 FAT16 (LBA)\", 0x0F: \"W95 extended (LBA)\", 0x11: \"Hidden FAT12\", 0x14: \"Hidden FAT16 <32M\", 0x16: \"Hidden FAT16\", 0x17: \"Hidden HPFS/NTFS\", 0x1B: \"Hidden W95 FAT32\", 0x1C: \"Hidden W95 FAT32 (LBA)\", 0x1E: \"Hidden W95 FAT16 (LBA)\", 0x27: \"Hidden NTFS WinRE\", 0x81: \"Minix / old Linux\", 0x82: \"Linux swap / Solaris\", 0x83: \"Linux\", 0x85: \"Linux extended\", 0x86: \"NTFS volume set\", 0x87: \"NTFS volume set\", 0x88: \"Linux plaintext\", 0x8E: \"Linux LVM\", 0x9F: \"BSD/OS\", 0xA5: \"FreeBSD\", 0xA6: \"OpenBSD\", 0xAF: \"HFS / HFS+\", 0xEA: \"Linux extended boot\", 0xEE: \"GPT\", 0xEF: \"EFI (FAT-12/16/32)\", 0xF2: \"DOS secondary\", 0xFB: \"VMware VMFS\", 0xFC: \"VMware VMKCORE\", 0xFD: \"Linux raid autodetect\", } class Position(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" struct { unsigned char head; unsigned char sector; unsigned char cyl; } \"\"\" class Partition(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" #define ACTIVE_FLAG 0x80 typedef struct Position Position; struct { unsigned char status; /* 0x80 - active */ Position start; unsigned char partition_type; Position end; unsigned int start_sect; /* starting sector counting from 0 */ unsigned int sectors; /* nr of sectors in partition */ } \"\"\" @property def bootable_str(self): return \"*\" if (self.status & cstruct.getdef(\"ACTIVE_FLAG\")) else \" \" @property def end_sect(self): return self.start_sect + self.sectors - 1 @property def part_size_str(self): val = self.sectors * SECTOR_SIZE for unit in UNITS: if val < 1000: break val = int(val / 1000) return f\"{val}{unit}\" @property def part_type_str(self): return TYPES.get(self.partition_type, \"\") def __str__(self): return f\"{self.bootable_str} {self.start_sect:>10} {self.end_sect:>8} {self.sectors:>8} {self.part_size_str:>4} {self.partition_type:02x} {self.part_type_str}\" class MBR(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __def__ = \"\"\" #define MBR_SIZE 512 #define MBR_DISK_SIGNATURE_SIZE 4 #define MBR_USUALY_NULLS_SIZE 2 #define MBR_SIGNATURE_SIZE 2 #define MBR_BOOT_SIGNATURE 0xaa55 #define MBR_PARTITIONS_NUM 4 #define MBR_PARTITIONS_SIZE (sizeof(Partition) * MBR_PARTITIONS_NUM) #define MBR_UNUSED_SIZE (MBR_SIZE - MBR_DISK_SIGNATURE_SIZE - MBR_USUALY_NULLS_SIZE - MBR_PARTITIONS_SIZE - MBR_SIGNATURE_SIZE) typedef struct Partition Partition; struct { char unused[MBR_UNUSED_SIZE]; unsigned char disk_signature[MBR_DISK_SIGNATURE_SIZE]; unsigned char usualy_nulls[MBR_USUALY_NULLS_SIZE]; Partition partitions[MBR_PARTITIONS_NUM]; uint16 signature; } \"\"\" @property def disk_signature_str(self): return \"\".join(reversed([f\"{x:02x}\" for x in self.disk_signature])) def print_info(self): print(f\"Sector size: {cstruct.getdef('MBR_SIZE')}\") if self.signature != cstruct.getdef('MBR_BOOT_SIGNATURE'): print(\"Invalid MBR signature\") print(f\"Disk identifier: 0x{self.disk_signature_str}\") print() print(\"Device Boot Start End Sectors Size Id Type\") for i, partition in enumerate(self.partitions): if partition.sectors: print(f\"part{i:<2} {partition}\") def main(): parser = argparse.ArgumentParser(description=\"Display or manipulate a disk partition table.\") parser.add_argument(\"disk\") args = parser.parse_args() try: with Path(args.disk).open(\"rb\") as f: mbr = MBR() data = f.read(len(mbr)) mbr.unpack(data) mbr.print_info() except (IOError, OSError) as ex: print(ex) sys.exit(1) if __name__ == \"__main__\": main()","title":"fdisk.py"},{"location":"examples/flexible_array/","text":"Flexible Array Member (FAM) example. #!/usr/bin/env python import random from pathlib import Path from cstruct import MemCStruct class FlexArray(MemCStruct): __def__ = \"\"\" struct { int length; uint32 checksum; long data[]; } \"\"\" def set_length(self, length): self.length = length self.set_flexible_array_length(length) def write(filename, length): print(\"---write---\") flex = FlexArray() flex.set_length(length) # Generate random data flex.data = [random.randint(0, 2**63) for _ in range(0, length)] # Calculate the checksum flex.checksum = 0 for num in flex.data: flex.checksum = (flex.checksum + num) % 2**32 print(f\"checksum: {flex.checksum}\") # Write data with Path(filename).open(\"wb\") as f: f.write(flex.pack()) def read(filename): print(\"---read---\") with Path(filename).open(\"rb\") as f: # Read the header flex = FlexArray(f) print(f\"length: {flex.length}, checksum: {flex.checksum}\") # Read header and data f.seek(0, 0) flex.unpack(f, flexible_array_length=flex.length) if len(flex.data) == flex.length: print(\"length ok\") # Check the checksum checksum = 0 for num in flex.data: checksum = (checksum + num) % 2**32 if flex.checksum == checksum: print(\"checksum ok\") def main(): filename = \"tempfile\" random.seed(5) write(filename, 1000) read(filename) if __name__ == \"__main__\": main()","title":"flexible_array.py"},{"location":"examples/who/","text":"The following program prints information about users who are currently logged in. #!/usr/bin/env python import argparse import sys import time from pathlib import Path from cstruct import NATIVE_ORDER, MemCStruct, getdef, parse DEFAULT_FILENAME = \"/var/run/utmp\" parse( \"\"\" /* Values for ut_type field, below */ #define EMPTY 0 /* Record does not contain valid info (formerly known as UT_UNKNOWN on Linux) */ #define RUN_LVL 1 /* Change in system run-level (see init(1)) */ #define BOOT_TIME 2 /* Time of system boot (in ut_tv) */ #define NEW_TIME 3 /* Time after system clock change (in ut_tv) */ #define OLD_TIME 4 /* Time before system clock change (in ut_tv) */ #define INIT_PROCESS 5 /* Process spawned by init(1) */ #define LOGIN_PROCESS 6 /* Session leader process for user login */ #define USER_PROCESS 7 /* Normal process */ #define DEAD_PROCESS 8 /* Terminated process */ #define ACCOUNTING 9 /* Not implemented */ #define UT_LINESIZE 32 #define UT_NAMESIZE 32 #define UT_HOSTSIZE 256 typedef int pid_t; typedef long time_t; \"\"\" ) class ExitStatus(MemCStruct): __def__ = \"\"\" struct ExitStatus { short e_termination; /* Process termination status. */ short e_exit; /* Process exit status. */ } \"\"\" class Timeval(MemCStruct): __def__ = \"\"\" struct { int32_t tv_sec; /* Seconds. */ int32_t tv_usec; /* Microseconds. */ } \"\"\" def str_from_c(string): return string.decode().split(\"\\0\")[0] class Utmp(MemCStruct): __byte_order__ = NATIVE_ORDER __def__ = \"\"\" typedef struct ExitStatus ExitStatus; struct { short ut_type; /* Type of record */ pid_t ut_pid; /* PID of login process */ char ut_line[UT_LINESIZE]; /* Device name of tty - \"/dev/\" */ char ut_id[4]; /* Terminal name suffix, or inittab(5) ID */ char ut_user[UT_NAMESIZE]; /* Username */ char ut_host[UT_HOSTSIZE]; /* Hostname for remote login, or kernel version for run-level messages */ ExitStatus ut_exit; /* Exit status of a process marked as DEAD_PROCESS; not used by Linux init (1 */ int32_t ut_session; /* Session ID (getsid(2)), used for windowing */ struct { int32_t tv_sec; /* Seconds */ int32_t tv_usec; /* Microseconds */ } ut_tv; /* Time entry was made */ int32_t ut_addr_v6[4]; /* Internet address of remote host; IPv4 address uses just ut_addr_v6[0] */ char __unused[20]; /* Reserved for future use */ } \"\"\" @property def user(self): return str_from_c(self.ut_user) @property def line(self): return str_from_c(self.ut_line) @property def time(self): return time.strftime(\"%Y-%m-%d %H:%M\", time.gmtime(self.ut_tv.tv_sec)) @property def host(self): if str_from_c(self.ut_host): host = str_from_c(self.ut_host) return f\"({host})\" elif self.ut_id: ut_id = str_from_c(self.ut_id) return f\"id={ut_id}\" else: return \"\" def __str__(self): return f\"{self.user:<10s} {self.line:<12s} {self.time:<15s} {self.ut_pid:>15} {self.host:<8s}\" def print_info(self, show_all): if show_all or self.ut_type in (getdef('LOGIN_PROCESS'), getdef('USER_PROCESS')): print(self) def main(): parser = argparse.ArgumentParser(description=\"Print information about users who are currently logged in.\") parser.add_argument(\"-a\", \"--all\", action=\"store_true\", dest=\"show_all\", help=\"show all enties\") parser.add_argument(\"file\", nargs=\"?\", help=\"if FILE is not specified use /var/run/utmp\", default=DEFAULT_FILENAME) args = parser.parse_args() utmp = Utmp() try: with Path(args.file).open(\"rb\") as f: while utmp.unpack(f): utmp.print_info(args.show_all) except (IOError, OSError) as ex: print(ex) sys.exit(1) if __name__ == \"__main__\": main()","title":"who.py"}]}