{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python-CStruct Convert C struct/union definitions into Python classes with methods for serializing/deserializing. The usage is very simple: create a class subclassing cstruct.MemCStruct and add a C struct/union definition as a string in the __struct__ field. The C struct/union definition is parsed at runtime and the struct format string is generated. The class offers the method unpack for deserializing an array of bytes into a Python object and the method pack for serializing the values into an array of bytes.","title":"CStruct Docs"},{"location":"#python-cstruct","text":"Convert C struct/union definitions into Python classes with methods for serializing/deserializing. The usage is very simple: create a class subclassing cstruct.MemCStruct and add a C struct/union definition as a string in the __struct__ field. The C struct/union definition is parsed at runtime and the struct format string is generated. The class offers the method unpack for deserializing an array of bytes into a Python object and the method pack for serializing the values into an array of bytes.","title":"Python-CStruct"},{"location":"license/","text":"The MIT License (MIT) Copyright (c) 2013-2022 Andrea Bonomi andrea.bonomi@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"api/abstract/","text":"AbstractCStruct Abstract C struct to Python class Source code in cstruct/abstract.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class AbstractCStruct ( metaclass = CStructMeta ): \"\"\" Abstract C struct to Python class \"\"\" __size__ : int = 0 \" Size in bytes \" __fields__ : List [ str ] = [] \" Struct/union fileds \" __fields_types__ : Dict [ str , FieldType ] \" Dictionary mapping field names to types \" __byte_order__ : Optional [ str ] = None \" Byte order \" __alignment__ : int = 0 \" Alignament \" __is_union__ : bool = False \" True if the class is an union, False if it is a struct \" def __init__ ( self , buffer : Optional [ Union [ bytes , BinaryIO ]] = None , flexible_array_length : Optional [ int ] = None , ** kargs : Dict [ str , Any ] ) -> None : self . set_flexible_array_length ( flexible_array_length ) self . __fields__ = [ x for x in self . __fields__ ] # Create a copy self . __fields_types__ = OrderedDict ({ k : v . copy () for k , v in self . __fields_types__ . items ()}) # Create a copy if buffer is not None : self . unpack ( buffer ) else : try : self . unpack ( buffer ) except Exception : pass for key , value in kargs . items (): setattr ( self , key , value ) @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ] ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the defintion \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ '__byte_order__' ] = __byte_order__ if __is_union__ is not None : cls_kargs [ '__is_union__' ] = __is_union__ cls_kargs [ '__struct__' ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ '__struct__' ] cls_kargs . update ( parse_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ '__struct__' ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ '__struct__' ] cls_kargs . update ( __struct__ ) cls_kargs [ '__struct__' ] = None if __name__ is None : # Anonymous struct __name__ = cls . __name__ + '_' + hashlib . sha1 ( str ( __struct__ ) . encode ( 'utf-8' )) . hexdigest () cls_kargs [ '__anonymous__' ] = True cls_kargs [ '__name__' ] = __name__ return type ( __name__ , ( cls ,), cls_kargs ) def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen = flexible_array_length def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , 'read' ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer ) def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError def clear ( self ) -> None : self . unpack ( None ) def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size @property def size ( self ) -> int : \"Actual structure size (in bytes)\" if not self . __fields_types__ : # no fields return 0 elif self . __is_union__ : # C union # Calculate the sizeof union as size of its largest element return max ( x . vsize for x in self . __fields_types__ . values ()) else : # C struct # Calculate the sizeof struct as last item's offset + size + padding last_field_type = list ( self . __fields_types__ . values ())[ - 1 ] size = last_field_type . offset + last_field_type . vsize padding = calculate_padding ( self . __byte_order__ , self . __alignment__ , size ) return size + padding @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__ def __eq__ ( self , other : Any ) -> bool : return other is not None and isinstance ( other , self . __class__ ) and self . __dict__ == other . __dict__ def __ne__ ( self , other : Any ) -> bool : return not self . __eq__ ( other ) def __str__ ( self ) -> str : result = [] for field in self . __fields__ : result . append ( field + \"=\" + str ( getattr ( self , field , None ))) return type ( self ) . __name__ + \"(\" + \", \" . join ( result ) + \")\" def __repr__ ( self ) -> str : # pragma: no cover return self . __str__ () def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack () def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state ) __alignment__ : int = 0 class-attribute Alignament __byte_order__ : Optional [ str ] = None class-attribute Byte order __is_union__ : bool = False class-attribute True if the class is an union, False if it is a struct __size__ : int = 0 class-attribute Size in bytes __getstate__ () This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/abstract.py 241 242 243 244 245 246 247 248 249 250 def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack () __len__ () Actual structure size (in bytes) Source code in cstruct/abstract.py 202 203 204 def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size __setstate__ ( state ) This method it is called with the unpickled state Parameters: Name Type Description Default state bytes bytes to be unpacked required Source code in cstruct/abstract.py 252 253 254 255 256 257 258 259 def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state ) pack () Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/abstract.py 190 191 192 193 194 195 196 197 def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError parse ( __struct__ , __name__ = None , __byte_order__ = None , __is_union__ = False , ** kargs ) classmethod Return a new class mapping a C struct/union definition. Parameters: Name Type Description Default __struct__ Union [ str , Tokens , Dict [ str , Any ]] definition of the struct (or union) in C syntax required __name__ Optional [ str ] name of the new class. If empty, a name based on the struct hash is generated None __byte_order__ Optional [ str ] byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER None __is_union__ Optional [ bool ] True for union, False for struct False Returns: Name Type Description cls Type [ AbstractCStruct ] a new class mapping the defintion Source code in cstruct/abstract.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ] ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the defintion \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ '__byte_order__' ] = __byte_order__ if __is_union__ is not None : cls_kargs [ '__is_union__' ] = __is_union__ cls_kargs [ '__struct__' ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ '__struct__' ] cls_kargs . update ( parse_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ '__struct__' ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ '__struct__' ] cls_kargs . update ( __struct__ ) cls_kargs [ '__struct__' ] = None if __name__ is None : # Anonymous struct __name__ = cls . __name__ + '_' + hashlib . sha1 ( str ( __struct__ ) . encode ( 'utf-8' )) . hexdigest () cls_kargs [ '__anonymous__' ] = True cls_kargs [ '__name__' ] = __name__ return type ( __name__ , ( cls ,), cls_kargs ) set_flexible_array_length ( flexible_array_length ) Set flexible array length (i.e. number of elements) Parameters: Name Type Description Default flexible_array_length Optional [ int ] flexible array length required Raises: Type Description CStructException If flexible array is not present in the structure Source code in cstruct/abstract.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen = flexible_array_length size () property Actual structure size (in bytes) Source code in cstruct/abstract.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @property def size ( self ) -> int : \"Actual structure size (in bytes)\" if not self . __fields_types__ : # no fields return 0 elif self . __is_union__ : # C union # Calculate the sizeof union as size of its largest element return max ( x . vsize for x in self . __fields_types__ . values ()) else : # C struct # Calculate the sizeof struct as last item's offset + size + padding last_field_type = list ( self . __fields_types__ . values ())[ - 1 ] size = last_field_type . offset + last_field_type . vsize padding = calculate_padding ( self . __byte_order__ , self . __alignment__ , size ) return size + padding sizeof () classmethod Structure size in bytes (flexible array member size is omitted) Source code in cstruct/abstract.py 221 222 223 224 @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__ unpack ( buffer , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ Union [ bytes , BinaryIO ]] bytes or binary stream to be unpacked required flexible_array_length Optional [ int ] flexible array length None Source code in cstruct/abstract.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , 'read' ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer ) unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] flexible array length None Source code in cstruct/abstract.py 177 178 179 180 181 182 183 184 185 186 187 188 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError CStructMeta Bases: ABCMeta Source code in cstruct/abstract.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class CStructMeta ( ABCMeta ): __size__ : int = 0 def __new__ ( metacls : Type [ type ], name : str , bases : Tuple [ str ], namespace : Dict [ str , Any ]) -> Type [ Any ]: __struct__ = namespace . get ( '__struct__' , None ) namespace [ '__cls__' ] = bases [ 0 ] if bases else None # Parse the struct if '__struct__' in namespace : if isinstance ( namespace [ '__struct__' ], ( str , Tokens )): namespace . update ( parse_struct ( ** namespace )) __struct__ = True if '__def__' in namespace : namespace . update ( parse_def ( ** namespace )) __struct__ = True # Create the new class new_class : Type [ Any ] = super () . __new__ ( metacls , name , bases , namespace ) # Register the class if __struct__ is not None and not namespace . get ( '__anonymous__' ): STRUCTS [ name ] = new_class return new_class def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ @property def size ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ __len__ () Structure size (in bytes) Source code in cstruct/abstract.py 60 61 62 def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ size () property Structure size (in bytes) Source code in cstruct/abstract.py 64 65 66 67 @property def size ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"cstruct.abstract"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct","text":"Abstract C struct to Python class Source code in cstruct/abstract.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 class AbstractCStruct ( metaclass = CStructMeta ): \"\"\" Abstract C struct to Python class \"\"\" __size__ : int = 0 \" Size in bytes \" __fields__ : List [ str ] = [] \" Struct/union fileds \" __fields_types__ : Dict [ str , FieldType ] \" Dictionary mapping field names to types \" __byte_order__ : Optional [ str ] = None \" Byte order \" __alignment__ : int = 0 \" Alignament \" __is_union__ : bool = False \" True if the class is an union, False if it is a struct \" def __init__ ( self , buffer : Optional [ Union [ bytes , BinaryIO ]] = None , flexible_array_length : Optional [ int ] = None , ** kargs : Dict [ str , Any ] ) -> None : self . set_flexible_array_length ( flexible_array_length ) self . __fields__ = [ x for x in self . __fields__ ] # Create a copy self . __fields_types__ = OrderedDict ({ k : v . copy () for k , v in self . __fields_types__ . items ()}) # Create a copy if buffer is not None : self . unpack ( buffer ) else : try : self . unpack ( buffer ) except Exception : pass for key , value in kargs . items (): setattr ( self , key , value ) @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ] ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the defintion \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ '__byte_order__' ] = __byte_order__ if __is_union__ is not None : cls_kargs [ '__is_union__' ] = __is_union__ cls_kargs [ '__struct__' ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ '__struct__' ] cls_kargs . update ( parse_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ '__struct__' ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ '__struct__' ] cls_kargs . update ( __struct__ ) cls_kargs [ '__struct__' ] = None if __name__ is None : # Anonymous struct __name__ = cls . __name__ + '_' + hashlib . sha1 ( str ( __struct__ ) . encode ( 'utf-8' )) . hexdigest () cls_kargs [ '__anonymous__' ] = True cls_kargs [ '__name__' ] = __name__ return type ( __name__ , ( cls ,), cls_kargs ) def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen = flexible_array_length def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , 'read' ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer ) def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError def clear ( self ) -> None : self . unpack ( None ) def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size @property def size ( self ) -> int : \"Actual structure size (in bytes)\" if not self . __fields_types__ : # no fields return 0 elif self . __is_union__ : # C union # Calculate the sizeof union as size of its largest element return max ( x . vsize for x in self . __fields_types__ . values ()) else : # C struct # Calculate the sizeof struct as last item's offset + size + padding last_field_type = list ( self . __fields_types__ . values ())[ - 1 ] size = last_field_type . offset + last_field_type . vsize padding = calculate_padding ( self . __byte_order__ , self . __alignment__ , size ) return size + padding @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__ def __eq__ ( self , other : Any ) -> bool : return other is not None and isinstance ( other , self . __class__ ) and self . __dict__ == other . __dict__ def __ne__ ( self , other : Any ) -> bool : return not self . __eq__ ( other ) def __str__ ( self ) -> str : result = [] for field in self . __fields__ : result . append ( field + \"=\" + str ( getattr ( self , field , None ))) return type ( self ) . __name__ + \"(\" + \", \" . join ( result ) + \")\" def __repr__ ( self ) -> str : # pragma: no cover return self . __str__ () def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack () def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state )","title":"AbstractCStruct"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__alignment__","text":"Alignament","title":"__alignment__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__byte_order__","text":"Byte order","title":"__byte_order__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__is_union__","text":"True if the class is an union, False if it is a struct","title":"__is_union__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__size__","text":"Size in bytes","title":"__size__"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__getstate__","text":"This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/abstract.py 241 242 243 244 245 246 247 248 249 250 def __getstate__ ( self ) -> bytes : \"\"\" This method is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance\u2019s dictionary Returns: bytes: The packed structure \"\"\" return self . pack ()","title":"__getstate__()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__len__","text":"Actual structure size (in bytes) Source code in cstruct/abstract.py 202 203 204 def __len__ ( self ) -> int : \"Actual structure size (in bytes)\" return self . size","title":"__len__()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.__setstate__","text":"This method it is called with the unpickled state Parameters: Name Type Description Default state bytes bytes to be unpacked required Source code in cstruct/abstract.py 252 253 254 255 256 257 258 259 def __setstate__ ( self , state : bytes ) -> bool : \"\"\" This method it is called with the unpickled state Args: state: bytes to be unpacked \"\"\" return self . unpack ( state )","title":"__setstate__()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.pack","text":"Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/abstract.py 190 191 192 193 194 195 196 197 def pack ( self ) -> bytes : # pragma: no cover \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" raise NotImplementedError","title":"pack()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.parse","text":"Return a new class mapping a C struct/union definition. Parameters: Name Type Description Default __struct__ Union [ str , Tokens , Dict [ str , Any ]] definition of the struct (or union) in C syntax required __name__ Optional [ str ] name of the new class. If empty, a name based on the struct hash is generated None __byte_order__ Optional [ str ] byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER None __is_union__ Optional [ bool ] True for union, False for struct False Returns: Name Type Description cls Type [ AbstractCStruct ] a new class mapping the defintion Source code in cstruct/abstract.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 @classmethod def parse ( cls , __struct__ : Union [ str , Tokens , Dict [ str , Any ]], __name__ : Optional [ str ] = None , __byte_order__ : Optional [ str ] = None , __is_union__ : Optional [ bool ] = False , ** kargs : Dict [ str , Any ] ) -> Type [ \"AbstractCStruct\" ]: \"\"\" Return a new class mapping a C struct/union definition. Args: __struct__: definition of the struct (or union) in C syntax __name__: name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__: byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__: True for union, False for struct Returns: cls: a new class mapping the defintion \"\"\" cls_kargs : Dict [ str , Any ] = dict ( kargs ) if __byte_order__ is not None : cls_kargs [ '__byte_order__' ] = __byte_order__ if __is_union__ is not None : cls_kargs [ '__is_union__' ] = __is_union__ cls_kargs [ '__struct__' ] = __struct__ if isinstance ( __struct__ , ( str , Tokens )): del cls_kargs [ '__struct__' ] cls_kargs . update ( parse_def ( __struct__ , __cls__ = cls , ** cls_kargs )) cls_kargs [ '__struct__' ] = None elif isinstance ( __struct__ , dict ): del cls_kargs [ '__struct__' ] cls_kargs . update ( __struct__ ) cls_kargs [ '__struct__' ] = None if __name__ is None : # Anonymous struct __name__ = cls . __name__ + '_' + hashlib . sha1 ( str ( __struct__ ) . encode ( 'utf-8' )) . hexdigest () cls_kargs [ '__anonymous__' ] = True cls_kargs [ '__name__' ] = __name__ return type ( __name__ , ( cls ,), cls_kargs )","title":"parse()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.set_flexible_array_length","text":"Set flexible array length (i.e. number of elements) Parameters: Name Type Description Default flexible_array_length Optional [ int ] flexible array length required Raises: Type Description CStructException If flexible array is not present in the structure Source code in cstruct/abstract.py 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length Raises: CStructException: If flexible array is not present in the structure \"\"\" if flexible_array_length is not None : # Search for the flexible array flexible_array : Optional [ FieldType ] = [ x for x in self . __fields_types__ . values () if x . flexible_array ][ 0 ] if flexible_array is None : raise CStructException ( \"Flexible array not found in struct\" ) flexible_array . vlen = flexible_array_length","title":"set_flexible_array_length()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.size","text":"Actual structure size (in bytes) Source code in cstruct/abstract.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 @property def size ( self ) -> int : \"Actual structure size (in bytes)\" if not self . __fields_types__ : # no fields return 0 elif self . __is_union__ : # C union # Calculate the sizeof union as size of its largest element return max ( x . vsize for x in self . __fields_types__ . values ()) else : # C struct # Calculate the sizeof struct as last item's offset + size + padding last_field_type = list ( self . __fields_types__ . values ())[ - 1 ] size = last_field_type . offset + last_field_type . vsize padding = calculate_padding ( self . __byte_order__ , self . __alignment__ , size ) return size + padding","title":"size()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.sizeof","text":"Structure size in bytes (flexible array member size is omitted) Source code in cstruct/abstract.py 221 222 223 224 @classmethod def sizeof ( cls ) -> int : \"Structure size in bytes (flexible array member size is omitted)\" return cls . __size__","title":"sizeof()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.unpack","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ Union [ bytes , BinaryIO ]] bytes or binary stream to be unpacked required flexible_array_length Optional [ int ] flexible array length None Source code in cstruct/abstract.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def unpack ( self , buffer : Optional [ Union [ bytes , BinaryIO ]], flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes or binary stream to be unpacked flexible_array_length: flexible array length \"\"\" self . set_flexible_array_length ( flexible_array_length ) if hasattr ( buffer , 'read' ): buffer = buffer . read ( self . size ) # type: ignore if not buffer : return False return self . unpack_from ( buffer )","title":"unpack()"},{"location":"api/abstract/#cstruct.abstract.AbstractCStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] flexible array length None Source code in cstruct/abstract.py 177 178 179 180 181 182 183 184 185 186 187 188 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : # pragma: no cover \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: flexible array length \"\"\" raise NotImplementedError","title":"unpack_from()"},{"location":"api/abstract/#cstruct.abstract.CStructMeta","text":"Bases: ABCMeta Source code in cstruct/abstract.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class CStructMeta ( ABCMeta ): __size__ : int = 0 def __new__ ( metacls : Type [ type ], name : str , bases : Tuple [ str ], namespace : Dict [ str , Any ]) -> Type [ Any ]: __struct__ = namespace . get ( '__struct__' , None ) namespace [ '__cls__' ] = bases [ 0 ] if bases else None # Parse the struct if '__struct__' in namespace : if isinstance ( namespace [ '__struct__' ], ( str , Tokens )): namespace . update ( parse_struct ( ** namespace )) __struct__ = True if '__def__' in namespace : namespace . update ( parse_def ( ** namespace )) __struct__ = True # Create the new class new_class : Type [ Any ] = super () . __new__ ( metacls , name , bases , namespace ) # Register the class if __struct__ is not None and not namespace . get ( '__anonymous__' ): STRUCTS [ name ] = new_class return new_class def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__ @property def size ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"CStructMeta"},{"location":"api/abstract/#cstruct.abstract.CStructMeta.__len__","text":"Structure size (in bytes) Source code in cstruct/abstract.py 60 61 62 def __len__ ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"__len__()"},{"location":"api/abstract/#cstruct.abstract.CStructMeta.size","text":"Structure size (in bytes) Source code in cstruct/abstract.py 64 65 66 67 @property def size ( cls ) -> int : \"Structure size (in bytes)\" return cls . __size__","title":"size()"},{"location":"api/base/","text":"BIG_ENDIAN = '>' module-attribute Big-endian, std. size & alignment LITTLE_ENDIAN = '<' module-attribute Little-endian, std. size & alignment NATIVE_ORDER = '@' module-attribute Native order, size & alignment","title":"cstruct.base"},{"location":"api/base/#cstruct.base.BIG_ENDIAN","text":"Big-endian, std. size & alignment","title":"BIG_ENDIAN"},{"location":"api/base/#cstruct.base.LITTLE_ENDIAN","text":"Little-endian, std. size & alignment","title":"LITTLE_ENDIAN"},{"location":"api/base/#cstruct.base.NATIVE_ORDER","text":"Native order, size & alignment","title":"NATIVE_ORDER"},{"location":"api/c_expr/","text":"c_eval ( expr ) Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval ( '10 + (5 / 3)' ) 11 >>> c_eval ( '!0' ) 1 >>> c_eval ( 'sizeof(x)' ) 128 Parameters: Name Type Description Default expr str C expression required Returns: Name Type Description result Union [ int , float ] the expression evaluation result Raises: Type Description EvalError expression evaluation error Source code in cstruct/c_expr.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def c_eval ( expr : str ) -> Union [ int , float ]: \"\"\" Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval('10 + (5 / 3)') 11 >>> c_eval('!0') 1 >>> c_eval('sizeof(x)') 128 Args: expr: C expression Returns: result: the expression evaluation result Raises: EvalError: expression evaluation error \"\"\" try : expr = expr . replace ( \"!\" , \" not \" ) . replace ( \"&&\" , \" and \" ) . replace ( \"||\" , \" or \" ) return eval_node ( ast . parse ( expr . strip ()) . body [ 0 ]) except Exception : raise EvalError eval_compare ( node ) Evaluate a compare node Source code in cstruct/c_expr.py 81 82 83 84 85 86 87 88 89 def eval_compare ( node ) -> bool : \"Evaluate a compare node\" right = eval_node ( node . left ) for operation , comp in zip ( node . ops , node . comparators ): left = right right = eval_node ( comp ) if not OPS [ type ( operation )]( left , right ): return False return True eval_div ( node ) Evaluate div node (integer/float) Source code in cstruct/c_expr.py 92 93 94 95 96 97 98 99 def eval_div ( node ) -> Union [ int , float ]: \"Evaluate div node (integer/float)\" left = eval_node ( node . left ) right = eval_node ( node . right ) if isinstance ( left , float ) or isinstance ( right , float ): return operator . truediv ( left , right ) else : return operator . floordiv ( left , right ) eval_get ( node ) Get definition/struct by name Source code in cstruct/c_expr.py 73 74 75 76 77 78 def eval_get ( node ) -> Union [ int , float , Type [ \"AbstractCStruct\" ]]: \"Get definition/struct by name\" try : return DEFINES [ node . id ] except KeyError : return STRUCTS [ node . id ]","title":"cstruct.c_expr"},{"location":"api/c_expr/#cstruct.c_expr.c_eval","text":"Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval ( '10 + (5 / 3)' ) 11 >>> c_eval ( '!0' ) 1 >>> c_eval ( 'sizeof(x)' ) 128 Parameters: Name Type Description Default expr str C expression required Returns: Name Type Description result Union [ int , float ] the expression evaluation result Raises: Type Description EvalError expression evaluation error Source code in cstruct/c_expr.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def c_eval ( expr : str ) -> Union [ int , float ]: \"\"\" Evaluate a C arithmetic/logic expression and return the result Examples: >>> c_eval('10 + (5 / 3)') 11 >>> c_eval('!0') 1 >>> c_eval('sizeof(x)') 128 Args: expr: C expression Returns: result: the expression evaluation result Raises: EvalError: expression evaluation error \"\"\" try : expr = expr . replace ( \"!\" , \" not \" ) . replace ( \"&&\" , \" and \" ) . replace ( \"||\" , \" or \" ) return eval_node ( ast . parse ( expr . strip ()) . body [ 0 ]) except Exception : raise EvalError","title":"c_eval()"},{"location":"api/c_expr/#cstruct.c_expr.eval_compare","text":"Evaluate a compare node Source code in cstruct/c_expr.py 81 82 83 84 85 86 87 88 89 def eval_compare ( node ) -> bool : \"Evaluate a compare node\" right = eval_node ( node . left ) for operation , comp in zip ( node . ops , node . comparators ): left = right right = eval_node ( comp ) if not OPS [ type ( operation )]( left , right ): return False return True","title":"eval_compare()"},{"location":"api/c_expr/#cstruct.c_expr.eval_div","text":"Evaluate div node (integer/float) Source code in cstruct/c_expr.py 92 93 94 95 96 97 98 99 def eval_div ( node ) -> Union [ int , float ]: \"Evaluate div node (integer/float)\" left = eval_node ( node . left ) right = eval_node ( node . right ) if isinstance ( left , float ) or isinstance ( right , float ): return operator . truediv ( left , right ) else : return operator . floordiv ( left , right )","title":"eval_div()"},{"location":"api/c_expr/#cstruct.c_expr.eval_get","text":"Get definition/struct by name Source code in cstruct/c_expr.py 73 74 75 76 77 78 def eval_get ( node ) -> Union [ int , float , Type [ \"AbstractCStruct\" ]]: \"Get definition/struct by name\" try : return DEFINES [ node . id ] except KeyError : return STRUCTS [ node . id ]","title":"eval_get()"},{"location":"api/cstruct/","text":"CStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/cstruct.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) pack () Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/cstruct.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/cstruct.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True","title":"cstruct.cstruct"},{"location":"api/cstruct/#cstruct.cstruct.CStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/cstruct.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"CStruct"},{"location":"api/cstruct/#cstruct.cstruct.CStruct.pack","text":"Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/cstruct.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"pack()"},{"location":"api/cstruct/#cstruct.cstruct.CStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/cstruct.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True","title":"unpack_from()"},{"location":"api/field/","text":"FieldType Bases: object Struct/Union field Attributes: Name Type Description kind Kind struct/union/native c_type str field type ref AbstractCStruct struct/union class ref vlen int number of elements flexible_array bool True for flexible arrays offset int relative memory position of the field (relative to the struct) padding int padding Source code in cstruct/field.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 class FieldType ( object ): \"\"\" Struct/Union field Attributes: kind (Kind): struct/union/native c_type (str): field type ref (AbstractCStruct): struct/union class ref vlen (int): number of elements flexible_array (bool): True for flexible arrays offset (int): relative memory position of the field (relative to the struct) padding (int): padding \"\"\" def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen : int , flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen = vlen self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0 def unpack_from ( self , buffer : bytes , offset : int = 0 ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset Returns: data: The unpacked data \"\"\" if self . is_native : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data ) @property def is_array ( self ) -> bool : \"True if field is an array/flexible array\" return self . flexible_array or ( not ( self . vlen == 1 or self . c_type == 'char' )) @property def is_native ( self ) -> bool : \"True if the field is a native type (e.g. int, char)\" return self . kind == Kind . NATIVE @property def is_struct ( self ) -> bool : \"True if the field is a struct\" return self . kind == Kind . STRUCT @property def is_union ( self ) -> bool : \"True if the field is an union\" return self . kind == Kind . UNION @property def native_format ( self ) -> str : \"Field format (struct library format)\" if self . is_native : try : return C_TYPE_TO_FORMAT [ self . c_type ] except KeyError : raise ParserError ( \"Unknow type {} \" . format ( self . c_type )) else : return 'c' @property def fmt ( self ) -> str : \"Field format prefixed by byte order (struct library format)\" if self . is_native : fmt = ( str ( self . vlen ) if self . vlen > 1 or self . flexible_array else '' ) + self . native_format else : # Struct/Union fmt = str ( self . vlen * self . ref . sizeof ()) + self . native_format if self . byte_order : return self . byte_order + fmt else : return fmt @property def vsize ( self ) -> int : \"Field size in bytes\" return struct . calcsize ( self . fmt ) @property def alignment ( self ) -> int : \"Alignment\" if self . is_native : if self . byte_order is not None : return struct . calcsize ( self . byte_order + self . native_format ) else : return struct . calcsize ( self . native_format ) else : # struct/union return self . ref . __alignment__ def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != 'char' : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self ) __init__ ( kind , c_type , ref , vlen , flexible_array , byte_order , offset ) Initialize a Struct/Union field Parameters: Name Type Description Default kind Kind struct/union/native required c_type str field type required ref Optional [ Type [ AbstractCStruct ]] struct/union class ref required vlen int number of elements required flexible_array bool True for flexible arrays required offset int relative memory position of the field (relative to the struct) required Source code in cstruct/field.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen : int , flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen = vlen self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0 align_filed_offset () If the byte order is native, align the field Source code in cstruct/field.py 214 215 216 217 218 def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != 'char' : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding alignment () property Alignment Source code in cstruct/field.py 203 204 205 206 207 208 209 210 211 212 @property def alignment ( self ) -> int : \"Alignment\" if self . is_native : if self . byte_order is not None : return struct . calcsize ( self . byte_order + self . native_format ) else : return struct . calcsize ( self . native_format ) else : # struct/union return self . ref . __alignment__ copy () Return a shallow copy of this FieldType Source code in cstruct/field.py 220 221 222 def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self ) fmt () property Field format prefixed by byte order (struct library format) Source code in cstruct/field.py 186 187 188 189 190 191 192 193 194 195 196 @property def fmt ( self ) -> str : \"Field format prefixed by byte order (struct library format)\" if self . is_native : fmt = ( str ( self . vlen ) if self . vlen > 1 or self . flexible_array else '' ) + self . native_format else : # Struct/Union fmt = str ( self . vlen * self . ref . sizeof ()) + self . native_format if self . byte_order : return self . byte_order + fmt else : return fmt is_array () property True if field is an array/flexible array Source code in cstruct/field.py 155 156 157 158 @property def is_array ( self ) -> bool : \"True if field is an array/flexible array\" return self . flexible_array or ( not ( self . vlen == 1 or self . c_type == 'char' )) is_native () property True if the field is a native type (e.g. int, char) Source code in cstruct/field.py 160 161 162 163 @property def is_native ( self ) -> bool : \"True if the field is a native type (e.g. int, char)\" return self . kind == Kind . NATIVE is_struct () property True if the field is a struct Source code in cstruct/field.py 165 166 167 168 @property def is_struct ( self ) -> bool : \"True if the field is a struct\" return self . kind == Kind . STRUCT is_union () property True if the field is an union Source code in cstruct/field.py 170 171 172 173 @property def is_union ( self ) -> bool : \"True if the field is an union\" return self . kind == Kind . UNION native_format () property Field format (struct library format) Source code in cstruct/field.py 175 176 177 178 179 180 181 182 183 184 @property def native_format ( self ) -> str : \"Field format (struct library format)\" if self . is_native : try : return C_TYPE_TO_FORMAT [ self . c_type ] except KeyError : raise ParserError ( \"Unknow type {} \" . format ( self . c_type )) else : return 'c' pack ( data ) Pack the field into bytes Parameters: Name Type Description Default data Any data to be packed required Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/field.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data ) unpack_from ( buffer , offset = 0 ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer bytes bytes to be unpacked required offset int optional buffer offset 0 Returns: Name Type Description data Any The unpacked data Source code in cstruct/field.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def unpack_from ( self , buffer : bytes , offset : int = 0 ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset Returns: data: The unpacked data \"\"\" if self . is_native : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances vsize () property Field size in bytes Source code in cstruct/field.py 198 199 200 201 @property def vsize ( self ) -> int : \"Field size in bytes\" return struct . calcsize ( self . fmt ) Kind Bases: Enum Field type Source code in cstruct/field.py 50 51 52 53 54 55 56 57 58 59 60 class Kind ( Enum ): \"\"\" Field type \"\"\" NATIVE = 0 \"Native type (e.g. int, char)\" STRUCT = 1 \"Struct type\" UNION = 2 \"Union type\" NATIVE = 0 class-attribute Native type (e.g. int, char) STRUCT = 1 class-attribute Struct type UNION = 2 class-attribute Union type","title":"cstruct.field"},{"location":"api/field/#cstruct.field.FieldType","text":"Bases: object Struct/Union field Attributes: Name Type Description kind Kind struct/union/native c_type str field type ref AbstractCStruct struct/union class ref vlen int number of elements flexible_array bool True for flexible arrays offset int relative memory position of the field (relative to the struct) padding int padding Source code in cstruct/field.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 class FieldType ( object ): \"\"\" Struct/Union field Attributes: kind (Kind): struct/union/native c_type (str): field type ref (AbstractCStruct): struct/union class ref vlen (int): number of elements flexible_array (bool): True for flexible arrays offset (int): relative memory position of the field (relative to the struct) padding (int): padding \"\"\" def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen : int , flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen = vlen self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0 def unpack_from ( self , buffer : bytes , offset : int = 0 ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset Returns: data: The unpacked data \"\"\" if self . is_native : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data ) @property def is_array ( self ) -> bool : \"True if field is an array/flexible array\" return self . flexible_array or ( not ( self . vlen == 1 or self . c_type == 'char' )) @property def is_native ( self ) -> bool : \"True if the field is a native type (e.g. int, char)\" return self . kind == Kind . NATIVE @property def is_struct ( self ) -> bool : \"True if the field is a struct\" return self . kind == Kind . STRUCT @property def is_union ( self ) -> bool : \"True if the field is an union\" return self . kind == Kind . UNION @property def native_format ( self ) -> str : \"Field format (struct library format)\" if self . is_native : try : return C_TYPE_TO_FORMAT [ self . c_type ] except KeyError : raise ParserError ( \"Unknow type {} \" . format ( self . c_type )) else : return 'c' @property def fmt ( self ) -> str : \"Field format prefixed by byte order (struct library format)\" if self . is_native : fmt = ( str ( self . vlen ) if self . vlen > 1 or self . flexible_array else '' ) + self . native_format else : # Struct/Union fmt = str ( self . vlen * self . ref . sizeof ()) + self . native_format if self . byte_order : return self . byte_order + fmt else : return fmt @property def vsize ( self ) -> int : \"Field size in bytes\" return struct . calcsize ( self . fmt ) @property def alignment ( self ) -> int : \"Alignment\" if self . is_native : if self . byte_order is not None : return struct . calcsize ( self . byte_order + self . native_format ) else : return struct . calcsize ( self . native_format ) else : # struct/union return self . ref . __alignment__ def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != 'char' : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self )","title":"FieldType"},{"location":"api/field/#cstruct.field.FieldType.__init__","text":"Initialize a Struct/Union field Parameters: Name Type Description Default kind Kind struct/union/native required c_type str field type required ref Optional [ Type [ AbstractCStruct ]] struct/union class ref required vlen int number of elements required flexible_array bool True for flexible arrays required offset int relative memory position of the field (relative to the struct) required Source code in cstruct/field.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def __init__ ( self , kind : Kind , c_type : str , ref : Optional [ Type [ \"AbstractCStruct\" ]], vlen : int , flexible_array : bool , byte_order : Optional [ str ], offset : int , ) -> None : \"\"\" Initialize a Struct/Union field Args: kind: struct/union/native c_type: field type ref: struct/union class ref vlen: number of elements flexible_array: True for flexible arrays offset: relative memory position of the field (relative to the struct) \"\"\" self . kind = kind self . c_type = c_type self . ref = ref self . vlen = vlen self . flexible_array = flexible_array self . byte_order = byte_order self . offset = self . base_offset = offset self . padding = 0","title":"__init__()"},{"location":"api/field/#cstruct.field.FieldType.align_filed_offset","text":"If the byte order is native, align the field Source code in cstruct/field.py 214 215 216 217 218 def align_filed_offset ( self ) -> None : \"If the byte order is native, align the field\" if align ( self . byte_order ) and self . c_type != 'char' : self . padding = calculate_padding ( self . byte_order , self . alignment , self . base_offset ) self . offset = self . base_offset + self . padding","title":"align_filed_offset()"},{"location":"api/field/#cstruct.field.FieldType.alignment","text":"Alignment Source code in cstruct/field.py 203 204 205 206 207 208 209 210 211 212 @property def alignment ( self ) -> int : \"Alignment\" if self . is_native : if self . byte_order is not None : return struct . calcsize ( self . byte_order + self . native_format ) else : return struct . calcsize ( self . native_format ) else : # struct/union return self . ref . __alignment__","title":"alignment()"},{"location":"api/field/#cstruct.field.FieldType.copy","text":"Return a shallow copy of this FieldType Source code in cstruct/field.py 220 221 222 def copy ( self ) -> \"FieldType\" : \"Return a shallow copy of this FieldType\" return copy . copy ( self )","title":"copy()"},{"location":"api/field/#cstruct.field.FieldType.fmt","text":"Field format prefixed by byte order (struct library format) Source code in cstruct/field.py 186 187 188 189 190 191 192 193 194 195 196 @property def fmt ( self ) -> str : \"Field format prefixed by byte order (struct library format)\" if self . is_native : fmt = ( str ( self . vlen ) if self . vlen > 1 or self . flexible_array else '' ) + self . native_format else : # Struct/Union fmt = str ( self . vlen * self . ref . sizeof ()) + self . native_format if self . byte_order : return self . byte_order + fmt else : return fmt","title":"fmt()"},{"location":"api/field/#cstruct.field.FieldType.is_array","text":"True if field is an array/flexible array Source code in cstruct/field.py 155 156 157 158 @property def is_array ( self ) -> bool : \"True if field is an array/flexible array\" return self . flexible_array or ( not ( self . vlen == 1 or self . c_type == 'char' ))","title":"is_array()"},{"location":"api/field/#cstruct.field.FieldType.is_native","text":"True if the field is a native type (e.g. int, char) Source code in cstruct/field.py 160 161 162 163 @property def is_native ( self ) -> bool : \"True if the field is a native type (e.g. int, char)\" return self . kind == Kind . NATIVE","title":"is_native()"},{"location":"api/field/#cstruct.field.FieldType.is_struct","text":"True if the field is a struct Source code in cstruct/field.py 165 166 167 168 @property def is_struct ( self ) -> bool : \"True if the field is a struct\" return self . kind == Kind . STRUCT","title":"is_struct()"},{"location":"api/field/#cstruct.field.FieldType.is_union","text":"True if the field is an union Source code in cstruct/field.py 170 171 172 173 @property def is_union ( self ) -> bool : \"True if the field is an union\" return self . kind == Kind . UNION","title":"is_union()"},{"location":"api/field/#cstruct.field.FieldType.native_format","text":"Field format (struct library format) Source code in cstruct/field.py 175 176 177 178 179 180 181 182 183 184 @property def native_format ( self ) -> str : \"Field format (struct library format)\" if self . is_native : try : return C_TYPE_TO_FORMAT [ self . c_type ] except KeyError : raise ParserError ( \"Unknow type {} \" . format ( self . c_type )) else : return 'c'","title":"native_format()"},{"location":"api/field/#cstruct.field.FieldType.pack","text":"Pack the field into bytes Parameters: Name Type Description Default data Any data to be packed required Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/field.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def pack ( self , data : Any ) -> bytes : \"\"\" Pack the field into bytes Args: data: data to be packed Returns: bytes: The packed structure \"\"\" if self . flexible_array : self . vlen = len ( data ) # set flexible array size return struct . pack ( self . fmt , * data ) elif self . is_array : return struct . pack ( self . fmt , * data ) else : return struct . pack ( self . fmt , data )","title":"pack()"},{"location":"api/field/#cstruct.field.FieldType.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer bytes bytes to be unpacked required offset int optional buffer offset 0 Returns: Name Type Description data Any The unpacked data Source code in cstruct/field.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def unpack_from ( self , buffer : bytes , offset : int = 0 ) -> Any : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset Returns: data: The unpacked data \"\"\" if self . is_native : result = struct . unpack_from ( self . fmt , buffer , self . offset + offset ) if self . is_array : return list ( result ) else : return result [ 0 ] else : # struct/union if self . vlen == 1 : # single struct/union instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset ) return instance else : # multiple struct/union instances : List [ AbstractCStruct ] = [] for j in range ( 0 , self . vlen ): instance : AbstractCStruct = self . ref () # type: ignore instance . unpack_from ( buffer , self . offset + offset + j * instance . size ) instances . append ( instance ) return instances","title":"unpack_from()"},{"location":"api/field/#cstruct.field.FieldType.vsize","text":"Field size in bytes Source code in cstruct/field.py 198 199 200 201 @property def vsize ( self ) -> int : \"Field size in bytes\" return struct . calcsize ( self . fmt )","title":"vsize()"},{"location":"api/field/#cstruct.field.Kind","text":"Bases: Enum Field type Source code in cstruct/field.py 50 51 52 53 54 55 56 57 58 59 60 class Kind ( Enum ): \"\"\" Field type \"\"\" NATIVE = 0 \"Native type (e.g. int, char)\" STRUCT = 1 \"Struct type\" UNION = 2 \"Union type\"","title":"Kind"},{"location":"api/field/#cstruct.field.Kind.NATIVE","text":"Native type (e.g. int, char)","title":"NATIVE"},{"location":"api/field/#cstruct.field.Kind.STRUCT","text":"Struct type","title":"STRUCT"},{"location":"api/field/#cstruct.field.Kind.UNION","text":"Union type","title":"UNION"},{"location":"api/mem_cstruct/","text":"MemCStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __mem__ mutable character buffer __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size ) memcpy ( destination , source , num ) Copies the values of num bytes from source to the struct memory Parameters: Name Type Description Default destination int destination address required source bytes source data to be copied required num int number of bytes to copy required Source code in cstruct/mem_cstruct.py 83 84 85 86 87 88 89 90 91 92 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) pack () Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/mem_cstruct.py 94 95 96 97 98 99 100 101 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL set_flexible_array_length ( flexible_array_length ) Set flexible array length (i.e. number of elements) Parameters: Name Type Description Default flexible_array_length Optional [ int ] flexible array length required Source code in cstruct/mem_cstruct.py 103 104 105 106 107 108 109 110 111 112 113 114 115 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/mem_cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True","title":"cstruct.mem_cstruct"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __mem__ mutable character buffer __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size )","title":"MemCStruct"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.memcpy","text":"Copies the values of num bytes from source to the struct memory Parameters: Name Type Description Default destination int destination address required source bytes source data to be copied required num int number of bytes to copy required Source code in cstruct/mem_cstruct.py 83 84 85 86 87 88 89 90 91 92 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num )","title":"memcpy()"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.pack","text":"Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/mem_cstruct.py 94 95 96 97 98 99 100 101 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL","title":"pack()"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.set_flexible_array_length","text":"Set flexible array length (i.e. number of elements) Parameters: Name Type Description Default flexible_array_length Optional [ int ] flexible array length required Source code in cstruct/mem_cstruct.py 103 104 105 106 107 108 109 110 111 112 113 114 115 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass","title":"set_flexible_array_length()"},{"location":"api/mem_cstruct/#cstruct.mem_cstruct.MemCStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/mem_cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True","title":"unpack_from()"},{"location":"api/module/","text":"BIG_ENDIAN = '>' module-attribute Big-endian, std. size & alignment LITTLE_ENDIAN = '<' module-attribute Little-endian, std. size & alignment NATIVE_ORDER = '@' module-attribute Native order, size & alignment CStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/cstruct.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) pack () Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/cstruct.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result ) unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/cstruct.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True MemCStruct Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __mem__ mutable character buffer __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size ) memcpy ( destination , source , num ) Copies the values of num bytes from source to the struct memory Parameters: Name Type Description Default destination int destination address required source bytes source data to be copied required num int number of bytes to copy required Source code in cstruct/mem_cstruct.py 83 84 85 86 87 88 89 90 91 92 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) pack () Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/mem_cstruct.py 94 95 96 97 98 99 100 101 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL set_flexible_array_length ( flexible_array_length ) Set flexible array length (i.e. number of elements) Parameters: Name Type Description Default flexible_array_length Optional [ int ] flexible array length required Source code in cstruct/mem_cstruct.py 103 104 105 106 107 108 109 110 111 112 113 114 115 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass unpack_from ( buffer , offset = 0 , flexible_array_length = None ) Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/mem_cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True define ( key , value ) Define a constant that can be used in the C struct Parameters: Name Type Description Default key str identifier required value Any value of the constant required Source code in cstruct/__init__.py 63 64 65 66 67 68 69 70 71 def define ( key : str , value : Any ) -> None : \"\"\" Define a constant that can be used in the C struct Args: key: identifier value: value of the constant \"\"\" DEFINES [ key ] = value getdef ( key ) Return the value for a constant Parameters: Name Type Description Default key str identifier required Source code in cstruct/__init__.py 84 85 86 87 88 89 90 91 def getdef ( key : str ) -> Any : \"\"\" Return the value for a constant Args: key: identifier \"\"\" return DEFINES [ key ] parse ( __struct__ , __cls__ = None , __name__ = None , ** kargs ) Return a new class mapping a C struct/union definition. If the string does not contains any definition, return None. Parameters: Name Type Description Default __struct__ str definition of the struct (or union) in C syntax required __cls__ type super class - CStruct(default) or MemCStruct None __name__ str name of the new class. If empty, a name based on the struct hash is generated None __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER required __is_union__ bool True for union, False for struct (default) required Returns: Name Type Description cls Optional [ Type [ AbstractCStruct ]] cls subclass Source code in cstruct/__init__.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def parse ( __struct__ : str , __cls__ : Optional [ Type [ AbstractCStruct ]] = None , __name__ : Optional [ str ] = None , ** kargs : Dict [ str , Any ] ) -> Optional [ Type [ AbstractCStruct ]]: \"\"\" Return a new class mapping a C struct/union definition. If the string does not contains any definition, return None. Args: __struct__ (str): definition of the struct (or union) in C syntax __cls__ (type): super class - CStruct(default) or MemCStruct __name__ (str): name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union, False for struct (default) Returns: cls: __cls__ subclass \"\"\" if __cls__ is None : __cls__ = CStruct cls_def = parse_def ( __struct__ , __cls__ = __cls__ , ** kargs ) if cls_def is None : return None else : return __cls__ . parse ( cls_def , __name__ , ** kargs ) sizeof ( type_ ) Return the size of the type. Parameters: Name Type Description Default type_ str C type, struct or union (e.g. 'short int' or 'struct ZYZ') required Returns: Name Type Description size int size in bytes Source code in cstruct/__init__.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def sizeof ( type_ : str ) -> int : \"\"\" Return the size of the type. Args: type_: C type, struct or union (e.g. 'short int' or 'struct ZYZ') Returns: size: size in bytes \"\"\" while type_ in TYPEDEFS : type_ = TYPEDEFS [ type_ ] if isinstance ( type_ , CStructMeta ): return len ( type_ ) elif type_ . startswith ( 'struct ' ) or type_ . startswith ( 'union ' ): kind , type_ = type_ . split ( ' ' , 1 ) t = STRUCTS . get ( type_ , None ) if t is None : raise KeyError ( \"Unknow %s \\\" %s \\\" \" % ( kind , type_ )) else : return t . sizeof () else : ttype = C_TYPE_TO_FORMAT . get ( type_ , None ) if ttype is None : raise KeyError ( \"Unknow type \\\" \" + type_ + \" \\\" \" ) else : return struct . calcsize ( ttype ) typedef ( type_ , alias ) Define an alias name for a data type Parameters: Name Type Description Default type_ str data type required alias str new alias name required Source code in cstruct/__init__.py 94 95 96 97 98 99 100 101 102 def typedef ( type_ : str , alias : str ) -> None : \"\"\" Define an alias name for a data type Args: type_: data type alias: new alias name \"\"\" TYPEDEFS [ alias ] = type_ undef ( key ) Undefine a symbol that was previously defined with define Parameters: Name Type Description Default key str identifier required Source code in cstruct/__init__.py 74 75 76 77 78 79 80 81 def undef ( key : str ) -> None : \"\"\" Undefine a symbol that was previously defined with define Args: key: identifier \"\"\" del DEFINES [ key ]","title":"cstruct"},{"location":"api/module/#cstruct.BIG_ENDIAN","text":"Big-endian, std. size & alignment","title":"BIG_ENDIAN"},{"location":"api/module/#cstruct.LITTLE_ENDIAN","text":"Little-endian, std. size & alignment","title":"LITTLE_ENDIAN"},{"location":"api/module/#cstruct.NATIVE_ORDER","text":"Native order, size & alignment","title":"NATIVE_ORDER"},{"location":"api/module/#cstruct.CStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/cstruct.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class CStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"CStruct"},{"location":"api/module/#cstruct.cstruct.CStruct.pack","text":"Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/cstruct.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" result : List [ bytes ] = [] for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : if field_type . vlen == 1 : # single struct v = getattr ( self , field , field_type . ref ()) v = v . pack () result . append ( v ) else : # multiple struct values = getattr ( self , field , []) for j in range ( 0 , field_type . vlen ): try : v = values [ j ] except KeyError : v = field_type . ref () v = v . pack () result . append ( v ) else : data = getattr ( self , field ) result . append ( field_type . pack ( data )) return bytes () . join ( result )","title":"pack()"},{"location":"api/module/#cstruct.cstruct.CStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/cstruct.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) if buffer is None : buffer = CHAR_ZERO * self . size for field , field_type in self . __fields_types__ . items (): setattr ( self , field , field_type . unpack_from ( buffer , offset )) return True","title":"unpack_from()"},{"location":"api/module/#cstruct.MemCStruct","text":"Bases: AbstractCStruct Convert C struct definitions into Python classes. Attributes: Name Type Description __struct__ str definition of the struct (or union) in C syntax __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ bool True for union definitions, False for struct definitions __mem__ mutable character buffer __size__ int size of the structure in bytes (flexible array member size is omitted) __fields__ list list of structure fields __fields_types__ dict dictionary mapping field names to types Source code in cstruct/mem_cstruct.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 class MemCStruct ( AbstractCStruct ): \"\"\" Convert C struct definitions into Python classes. Attributes: __struct__ (str): definition of the struct (or union) in C syntax __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union definitions, False for struct definitions __mem__: mutable character buffer __size__ (int): size of the structure in bytes (flexible array member size is omitted) __fields__ (list): list of structure fields __fields_types__ (dict): dictionary mapping field names to types \"\"\" __mem__ = None def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num ) def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass def __getattr__ ( self , attr : str ) -> Any : field_type = self . __fields_types__ [ attr ] result = field_type . unpack_from ( self . __mem__ , self . __base__ ) if isinstance ( result , list ): return CStructList ( result , name = attr , parent = self ) else : return result def __setattr__ ( self , attr : str , value : Any ) -> None : field_type = self . __fields_types__ . get ( attr ) if field_type is None : object . __setattr__ ( self , attr , value ) elif field_type . is_struct or field_type . is_union : object . __setattr__ ( self , attr , value ) else : # native if field_type . flexible_array and len ( value ) != field_type . vlen : # flexible array size changed, resize the buffer field_type . vlen = len ( value ) ctypes . resize ( self . __mem__ , self . size + 1 ) addr = field_type . offset + self . __base__ self . memcpy ( addr , field_type . pack ( value ), field_type . vsize ) def on_change_list ( self , attr : str , key : int , value : Any ) -> None : field_type = self . __fields_types__ [ attr ] # Calculate the single field format and size fmt = ( self . __byte_order__ + field_type . fmt [ - 1 ]) if self . __byte_order__ is not None else field_type . fmt [ - 1 ] size = struct . calcsize ( fmt ) # Calculate the single field memory position addr = field_type . offset + self . __base__ + size * key # Update the memory self . memcpy ( addr , struct . pack ( fmt , value ), size )","title":"MemCStruct"},{"location":"api/module/#cstruct.mem_cstruct.MemCStruct.memcpy","text":"Copies the values of num bytes from source to the struct memory Parameters: Name Type Description Default destination int destination address required source bytes source data to be copied required num int number of bytes to copy required Source code in cstruct/mem_cstruct.py 83 84 85 86 87 88 89 90 91 92 def memcpy ( self , destination : int , source : bytes , num : int ) -> None : \"\"\" Copies the values of num bytes from source to the struct memory Args: destination: destination address source: source data to be copied num: number of bytes to copy \"\"\" ctypes . memmove ( ctypes . byref ( self . __mem__ , destination ), source , num )","title":"memcpy()"},{"location":"api/module/#cstruct.mem_cstruct.MemCStruct.pack","text":"Pack the structure data into bytes Returns: Name Type Description bytes bytes The packed structure Source code in cstruct/mem_cstruct.py 94 95 96 97 98 99 100 101 def pack ( self ) -> bytes : \"\"\" Pack the structure data into bytes Returns: bytes: The packed structure \"\"\" return self . __mem__ . raw [: - 1 ] # the buffer is one item larger than its size and the last element is NUL","title":"pack()"},{"location":"api/module/#cstruct.mem_cstruct.MemCStruct.set_flexible_array_length","text":"Set flexible array length (i.e. number of elements) Parameters: Name Type Description Default flexible_array_length Optional [ int ] flexible array length required Source code in cstruct/mem_cstruct.py 103 104 105 106 107 108 109 110 111 112 113 114 115 def set_flexible_array_length ( self , flexible_array_length : Optional [ int ]) -> None : \"\"\" Set flexible array length (i.e. number of elements) Args: flexible_array_length: flexible array length \"\"\" super () . set_flexible_array_length ( flexible_array_length ) if self . __mem__ is not None : try : ctypes . resize ( self . __mem__ , self . size + 1 ) except ValueError : pass","title":"set_flexible_array_length()"},{"location":"api/module/#cstruct.mem_cstruct.MemCStruct.unpack_from","text":"Unpack bytes containing packed C structure data Parameters: Name Type Description Default buffer Optional [ bytes ] bytes to be unpacked required offset int optional buffer offset 0 flexible_array_length Optional [ int ] optional flexible array lenght (number of elements) None Source code in cstruct/mem_cstruct.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def unpack_from ( self , buffer : Optional [ bytes ], offset : int = 0 , flexible_array_length : Optional [ int ] = None ) -> bool : \"\"\" Unpack bytes containing packed C structure data Args: buffer: bytes to be unpacked offset: optional buffer offset flexible_array_length: optional flexible array lenght (number of elements) \"\"\" self . set_flexible_array_length ( flexible_array_length ) self . __base__ = offset # Base offset if buffer is None : # the buffer is one item larger than its size and the last element is NUL self . __mem__ = ctypes . create_string_buffer ( self . size + 1 ) elif isinstance ( buffer , ctypes . Array ): self . __mem__ = buffer else : self . __mem__ = ctypes . create_string_buffer ( buffer ) for field , field_type in self . __fields_types__ . items (): if field_type . is_struct or field_type . is_union : setattr ( self , field , field_type . unpack_from ( self . __mem__ , offset )) return True","title":"unpack_from()"},{"location":"api/module/#cstruct.define","text":"Define a constant that can be used in the C struct Parameters: Name Type Description Default key str identifier required value Any value of the constant required Source code in cstruct/__init__.py 63 64 65 66 67 68 69 70 71 def define ( key : str , value : Any ) -> None : \"\"\" Define a constant that can be used in the C struct Args: key: identifier value: value of the constant \"\"\" DEFINES [ key ] = value","title":"define()"},{"location":"api/module/#cstruct.getdef","text":"Return the value for a constant Parameters: Name Type Description Default key str identifier required Source code in cstruct/__init__.py 84 85 86 87 88 89 90 91 def getdef ( key : str ) -> Any : \"\"\" Return the value for a constant Args: key: identifier \"\"\" return DEFINES [ key ]","title":"getdef()"},{"location":"api/module/#cstruct.parse","text":"Return a new class mapping a C struct/union definition. If the string does not contains any definition, return None. Parameters: Name Type Description Default __struct__ str definition of the struct (or union) in C syntax required __cls__ type super class - CStruct(default) or MemCStruct None __name__ str name of the new class. If empty, a name based on the struct hash is generated None __byte_order__ str byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER required __is_union__ bool True for union, False for struct (default) required Returns: Name Type Description cls Optional [ Type [ AbstractCStruct ]] cls subclass Source code in cstruct/__init__.py 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def parse ( __struct__ : str , __cls__ : Optional [ Type [ AbstractCStruct ]] = None , __name__ : Optional [ str ] = None , ** kargs : Dict [ str , Any ] ) -> Optional [ Type [ AbstractCStruct ]]: \"\"\" Return a new class mapping a C struct/union definition. If the string does not contains any definition, return None. Args: __struct__ (str): definition of the struct (or union) in C syntax __cls__ (type): super class - CStruct(default) or MemCStruct __name__ (str): name of the new class. If empty, a name based on the __struct__ hash is generated __byte_order__ (str): byte order, valid values are LITTLE_ENDIAN, BIG_ENDIAN, NATIVE_ORDER __is_union__ (bool): True for union, False for struct (default) Returns: cls: __cls__ subclass \"\"\" if __cls__ is None : __cls__ = CStruct cls_def = parse_def ( __struct__ , __cls__ = __cls__ , ** kargs ) if cls_def is None : return None else : return __cls__ . parse ( cls_def , __name__ , ** kargs )","title":"parse()"},{"location":"api/module/#cstruct.sizeof","text":"Return the size of the type. Parameters: Name Type Description Default type_ str C type, struct or union (e.g. 'short int' or 'struct ZYZ') required Returns: Name Type Description size int size in bytes Source code in cstruct/__init__.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 def sizeof ( type_ : str ) -> int : \"\"\" Return the size of the type. Args: type_: C type, struct or union (e.g. 'short int' or 'struct ZYZ') Returns: size: size in bytes \"\"\" while type_ in TYPEDEFS : type_ = TYPEDEFS [ type_ ] if isinstance ( type_ , CStructMeta ): return len ( type_ ) elif type_ . startswith ( 'struct ' ) or type_ . startswith ( 'union ' ): kind , type_ = type_ . split ( ' ' , 1 ) t = STRUCTS . get ( type_ , None ) if t is None : raise KeyError ( \"Unknow %s \\\" %s \\\" \" % ( kind , type_ )) else : return t . sizeof () else : ttype = C_TYPE_TO_FORMAT . get ( type_ , None ) if ttype is None : raise KeyError ( \"Unknow type \\\" \" + type_ + \" \\\" \" ) else : return struct . calcsize ( ttype )","title":"sizeof()"},{"location":"api/module/#cstruct.typedef","text":"Define an alias name for a data type Parameters: Name Type Description Default type_ str data type required alias str new alias name required Source code in cstruct/__init__.py 94 95 96 97 98 99 100 101 102 def typedef ( type_ : str , alias : str ) -> None : \"\"\" Define an alias name for a data type Args: type_: data type alias: new alias name \"\"\" TYPEDEFS [ alias ] = type_","title":"typedef()"},{"location":"api/module/#cstruct.undef","text":"Undefine a symbol that was previously defined with define Parameters: Name Type Description Default key str identifier required Source code in cstruct/__init__.py 74 75 76 77 78 79 80 81 def undef ( key : str ) -> None : \"\"\" Undefine a symbol that was previously defined with define Args: key: identifier \"\"\" del DEFINES [ key ]","title":"undef()"},{"location":"examples/fdisk/","text":"#!/usr/bin/env python from pathlib import Path import argparse import cstruct import sys UNITS = ['B', 'K', 'M', 'G', 'T'] SECTOR_SIZE = 512 TYPES = { 0x00: \"Empty\", 0x01: \"FAT12\", 0x05: \"Extended\", 0x06: \"FAT16\", 0x07: \"HPFS/NTFS/exFAT\", 0x0B: \"W95 FAT32\", 0x0C: \"W95 FAT32 (LBA)\", 0x0E: \"W95 FAT16 (LBA)\", 0x0F: \"W95 extended (LBA)\", 0x11: \"Hidden FAT12\", 0x14: \"Hidden FAT16 <32M\", 0x16: \"Hidden FAT16\", 0x17: \"Hidden HPFS/NTFS\", 0x1B: \"Hidden W95 FAT32\", 0x1C: \"Hidden W95 FAT32 (LBA)\", 0x1E: \"Hidden W95 FAT16 (LBA)\", 0x27: \"Hidden NTFS WinRE\", 0x81: \"Minix / old Linux\", 0x82: \"Linux swap / Solaris\", 0x83: \"Linux\", 0x85: \"Linux extended\", 0x86: \"NTFS volume set\", 0x87: \"NTFS volume set\", 0x88: \"Linux plaintext\", 0x8E: \"Linux LVM\", 0x9F: \"BSD/OS\", 0xA5: \"FreeBSD\", 0xA6: \"OpenBSD\", 0xAF: \"HFS / HFS+\", 0xEA: \"Linux extended boot\", 0xEE: \"GPT\", 0xEF: \"EFI (FAT-12/16/32)\", 0xF2: \"DOS secondary\", 0xFB: \"VMware VMFS\", 0xFC: \"VMware VMKCORE\", 0xFD: \"Linux raid autodetect\", } class Position(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __struct__ = \"\"\" unsigned char head; unsigned char sector; unsigned char cyl; \"\"\" class Partition(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __struct__ = \"\"\" #define ACTIVE_FLAG 0x80 unsigned char status; /* 0x80 - active */ struct Position start; unsigned char partition_type; struct Position end; unsigned int start_sect; /* starting sector counting from 0 */ unsigned int sectors; /* nr of sectors in partition */ \"\"\" @property def bootable_str(self): return \"*\" if (self.status & cstruct.getdef(\"ACTIVE_FLAG\")) else \" \" @property def end_sect(self): return self.start_sect + self.sectors - 1 @property def part_size_str(self): val = self.sectors * SECTOR_SIZE for unit in UNITS: if val < 1000: break val = int(val / 1000) return f\"{val}{unit}\" @property def part_type_str(self): return TYPES.get(self.partition_type, \"\") def __str__(self): return f\"{self.bootable_str} {self.start_sect:>10} {self.end_sect:>8} {self.sectors:>8} {self.part_size_str:>4} {self.partition_type:02x} {self.part_type_str}\" class MBR(cstruct.MemCStruct): __byte_order__ = cstruct.LITTLE_ENDIAN __struct__ = \"\"\" #define MBR_SIZE 512 #define MBR_DISK_SIGNATURE_SIZE 4 #define MBR_USUALY_NULLS_SIZE 2 #define MBR_SIGNATURE_SIZE 2 #define MBR_BOOT_SIGNATURE 0xaa55 #define MBR_PARTITIONS_NUM 4 #define MBR_PARTITIONS_SIZE (sizeof(Partition) * MBR_PARTITIONS_NUM) #define MBR_UNUSED_SIZE (MBR_SIZE - MBR_DISK_SIGNATURE_SIZE - MBR_USUALY_NULLS_SIZE - MBR_PARTITIONS_SIZE - MBR_SIGNATURE_SIZE) char unused[MBR_UNUSED_SIZE]; unsigned char disk_signature[MBR_DISK_SIGNATURE_SIZE]; unsigned char usualy_nulls[MBR_USUALY_NULLS_SIZE]; struct Partition partitions[MBR_PARTITIONS_NUM]; uint16 signature; \"\"\" @property def disk_signature_str(self): return \"\".join(reversed([f\"{x:02x}\" for x in self.disk_signature])) def print_info(self): print(f\"Sector size: {cstruct.getdef('MBR_SIZE')}\") if self.signature != cstruct.getdef('MBR_BOOT_SIGNATURE'): print(\"Invalid MBR signature\") print(f\"Disk identifier: 0x{self.disk_signature_str}\") print() print(\"Device Boot Start End Sectors Size Id Type\") for i, partition in enumerate(self.partitions): if partition.sectors: print(f\"part{i:<2} {partition}\") def main(): parser = argparse.ArgumentParser(description=\"Display or manipulate a disk partition table.\") parser.add_argument(\"disk\") args = parser.parse_args() try: with Path(args.disk).open(\"rb\") as f: mbr = MBR() data = f.read(len(mbr)) mbr.unpack(data) mbr.print_info() except (IOError, OSError) as ex: print(ex) sys.exit(1) if __name__ == \"__main__\": main()","title":"fdisk.py"},{"location":"examples/flexible_array/","text":"#!/usr/bin/env python import random from cstruct import MemCStruct from pathlib import Path class FlexArray(MemCStruct): __struct__ = \"\"\" int length; uint32 checksum; long data[]; \"\"\" def set_length(self, length): self.length = length self.set_flexible_array_length(length) def write(filename, length): print(\"---write---\") flex = FlexArray() flex.set_length(length) # Generate random data flex.data = [random.randint(0, 2**63) for _ in range(0, length)] # Calculate the checksum flex.checksum = 0 for num in flex.data: flex.checksum = (flex.checksum + num) % 2**32 print(f\"checksum: {flex.checksum}\") # Write data with Path(filename).open(\"wb\") as f: f.write(flex.pack()) def read(filename): print(\"---read---\") with Path(filename).open(\"rb\") as f: # Read the header flex = FlexArray(f) print(f\"length: {flex.length}, checksum: {flex.checksum}\") # Read header and data f.seek(0, 0) flex.unpack(f, flexible_array_length=flex.length) if len(flex.data) == flex.length: print(\"length ok\") # Check the checksum checksum = 0 for num in flex.data: checksum = (checksum + num) % 2**32 if flex.checksum == checksum: print(\"checksum ok\") def main(): filename = \"tempfile\" random.seed(5) write(filename, 1000) read(filename) if __name__ == \"__main__\": main()","title":"flexible_array.py"},{"location":"examples/who/","text":"#!/usr/bin/env python from cstruct import parse, getdef, typedef, MemCStruct, NATIVE_ORDER from pathlib import Path import argparse import sys import time DEFAULT_FILENAME = \"/var/run/utmp\" parse( \"\"\" /* Values for ut_type field, below */ #define EMPTY 0 /* Record does not contain valid info (formerly known as UT_UNKNOWN on Linux) */ #define RUN_LVL 1 /* Change in system run-level (see init(1)) */ #define BOOT_TIME 2 /* Time of system boot (in ut_tv) */ #define NEW_TIME 3 /* Time after system clock change (in ut_tv) */ #define OLD_TIME 4 /* Time before system clock change (in ut_tv) */ #define INIT_PROCESS 5 /* Process spawned by init(1) */ #define LOGIN_PROCESS 6 /* Session leader process for user login */ #define USER_PROCESS 7 /* Normal process */ #define DEAD_PROCESS 8 /* Terminated process */ #define ACCOUNTING 9 /* Not implemented */ #define UT_LINESIZE 32 #define UT_NAMESIZE 32 #define UT_HOSTSIZE 256 \"\"\" ) typedef(\"int\", \"pid_t\") typedef(\"long\", \"time_t\") class ExitStatus(MemCStruct): __struct__ = \"\"\" short e_termination; /* Process termination status. */ short e_exit; /* Process exit status. */ \"\"\" class Timeval(MemCStruct): __struct__ = \"\"\" int32_t tv_sec; /* Seconds. */ int32_t tv_usec; /* Microseconds. */ \"\"\" def str_from_c(string): return string.decode().split(\"\\0\")[0] class Utmp(MemCStruct): __byte_order__ = NATIVE_ORDER __struct__ = \"\"\" short ut_type; /* Type of record */ pid_t ut_pid; /* PID of login process */ char ut_line[UT_LINESIZE]; /* Device name of tty - \"/dev/\" */ char ut_id[4]; /* Terminal name suffix, or inittab(5) ID */ char ut_user[UT_NAMESIZE]; /* Username */ char ut_host[UT_HOSTSIZE]; /* Hostname for remote login, or kernel version for run-level messages */ struct ExitStatus ut_exit; /* Exit status of a process marked as DEAD_PROCESS; not used by Linux init (1 */ int32_t ut_session; /* Session ID (getsid(2)), used for windowing */ struct { int32_t tv_sec; /* Seconds */ int32_t tv_usec; /* Microseconds */ } ut_tv; /* Time entry was made */ int32_t ut_addr_v6[4]; /* Internet address of remote host; IPv4 address uses just ut_addr_v6[0] */ char __unused[20]; /* Reserved for future use */ \"\"\" @property def user(self): return str_from_c(self.ut_user) @property def line(self): return str_from_c(self.ut_line) @property def time(self): return time.strftime(\"%Y-%m-%d %H:%M\", time.gmtime(self.ut_tv.tv_sec)) @property def host(self): if str_from_c(self.ut_host): host = str_from_c(self.ut_host) return f\"({host})\" elif self.ut_id: ut_id = str_from_c(self.ut_id) return f\"id={ut_id}\" else: return \"\" def __str__(self): return f\"{self.user:<10s} {self.line:<12s} {self.time:<15s} {self.ut_pid:>15} {self.host:<8s}\" def print_info(self, show_all): if show_all or self.ut_type in (getdef('LOGIN_PROCESS'), getdef('USER_PROCESS')): print(self) def main(): parser = argparse.ArgumentParser(description=\"Print information about users who are currently logged in.\") parser.add_argument(\"-a\", \"--all\", action=\"store_true\", dest=\"show_all\", help=\"show all enties\") parser.add_argument(\"file\", nargs=\"?\", help=\"if FILE is not specified use /var/run/utmp\", default=DEFAULT_FILENAME) args = parser.parse_args() utmp = Utmp() try: with Path(args.file).open(\"rb\") as f: while utmp.unpack(f): utmp.print_info(args.show_all) except (IOError, OSError) as ex: print(ex) sys.exit(1) if __name__ == \"__main__\": main()","title":"who.py"}]}